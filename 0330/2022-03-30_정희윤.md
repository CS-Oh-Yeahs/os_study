## Process Synchronization과 관련된 고전적 문제 3가지

### Bounded-Buffer Problem(Producer-Consumer Problem)

- 버퍼의 크기가 유한한 환경에서 생산자-소비자 문제가 발생한다.
- 생산자 프로세스와 소비자 프로세스 두 종류가 있다.
- 생산자와 소비자가 여러 개 있다.
- 생산자는 공유 버퍼에 데이터를 하나 만들어서 집어 넣는 역할을 한다.
    - 주황색 버퍼 : 생산자가 데이터를 만들어서 집어 넣어 놓은 상황
    - 비어있는 버퍼 : 애초부터 비어있었던지, 소비자가 데이터를 꺼내 가서 데이터가 없는 상황
- 문제1
    - 소비자는 공유 버퍼의 데이터를 소비하는 역할을 한다.
    - 공유 버퍼이기 때문에 두 개의 생산자가 비어있는 버퍼에 동시에 도착해서 동시에 데이터를 만들어서 집어 넣으면 동기화 문제가 발생하게 된다.
        - 따라서 한 생산자 프로세스가 비어있는 버퍼에 도착하게 된다면 lock을 걸어놓고 데이터를 집어넣는 작업이 끝난 경우 lock을 풀어서 다른 프로세스들이 접근할 수 있도록 해야한다.
- 문제2
    - 버퍼가 유한하기 때문에 생기는 문제로, 만약 생산자들이 한꺼번에 도착해서 공유 버퍼를 가득 채웠을 때 소비자는 오지 않고 생산자가 또 도착해서 데이터를 버퍼에 넣고자 할 때 생산자 입장에서 사용할 수 있는 자원이 없는 상황이 발생한다. (생산자 입장에서 데이터를 집어 넣을 비어있는 버퍼가 없기 때문)
    - 생산자는 소비자가 나타나서 버퍼의 내용을 꺼내가야만 빈 버퍼가 생긴다.
    - 생산자 입장에서 자원 : 비어있는 버퍼
    - 반대로 소비자 입장에서, 갑자기 소비자가 많이 와서 공유되어 있는 데이터를 모두 가져가 버렸을 때, 더 이상 소비할 수 있는 자원이 없어지게 된다.
    - 이 때, 소비자 프로세스는 생산자 프로세스가 공유 데이터를 만들어서 버퍼에 넣어줄 때까지 기다려야 한다.
    - 소비자 입장에서 자원 : 내용이 들어있는 버퍼
- 세마포어의 역할
    - 프로세스들이 버퍼에 동시에 접근할 수 없도록 lock-unlock을 통해 버퍼에 접근하는 프로세스의 갯수가 1개로 유지되도록 하는 역할
    - 버퍼가 가득 차거나 버퍼가 텅 비었을 때 가용 자원의 갯수를 세는 역할


- 생산자의 역할
    - 빈 버퍼가 있는지 체크하고 없으면 기다린다.
    - 빈 버퍼가 생겼을 경우 공유 버퍼 전체에 lock을 걸어 다른 프로세스의 접근을 막는다.
    - 빈 버퍼에 데이터를 입력한다. → 비어있는 버퍼의 위치 즉 포인터를 하나 증가시킨다.
    - lock을 풀어 다른 프로세스의 접근을 허용해준다.
    - 내용이 들어있는 버퍼의 갯수를 하나 증가시켜준다. (소비자 입장에서 자원이기 때문)
- 소비자 프로세스의 역할
    - 내용이 들어있는 버퍼가 있는지 체크하고 없으면 기다린다. (생산자가 내용이 들어있는 버퍼를 하나 만들어줄 때까지)
    - 내용이 들어있는 버퍼가 생겼을 경우 공유 버퍼 전체에 lock을 걸고 데이터를 꺼내간다.
    - 내용이 들어있는 버퍼의 위치를 다음으로 바꾸어 주고 공유 버퍼의 lock을 푼다.
    - 빈 버퍼의 갯수를 하나 증가시킨다. (생산자 입장에서 자원이기 때문)
- 공유 버퍼가 공유데이터 자체가 된다.
- 포인터 변수 : 공유 데이터의 위치를 나타내주는 변수

- 생산자-소비자 문제를 세마포어가 포함된 의사 코드로 나타낸 것
- mutex=1 ⇒ 하나의 프로세스만 접근할 수 있도록 lock을 거는 세마포어

### Readers and Writers Problem

- 프로세스가 두 종류 - 읽는 프로세스, 쓰는 프로세스
- 공유 데이터를 DB라고 부른다.
- 프로세스는 DB에서 데이터를 읽거나 쓰는 두 종류의 역할을 한다.
- 두 종류의 프로세스가 여러 개 있다.
- 공유 데이터인 DB에는 lock을 걸어서 하나의 프로세스만 접근할 수 있도록 한다.
- 쓰는 작업은 동시에 여럿이 하면 안되지만 읽는 작업은 동시에 여러 프로세스가 수행해도 된다.
- 문제
    - 어떤 프로세스가 데이터를 읽고 있을 경우 다른 프로세스도 데이터를 읽을 수 있게 해야 한다.
    - 어떤 프로세스가 데이터를 쓰고 있을 경우 다른 프로세스는 데이터를 쓸 수 없게 해야 한다.

- DB : 공유 데이터 → 접근을 위해서는 lock을 걸어야 함
- db : 공유 데이터에 접근하기 위한 lock 변수
- 데이터를 읽을 때 lock을 걸긴 해야한다. 걸지 않으면 데이터를 쓰고자 하는 writer가 와서 데이터를 써버릴 수 있기 때문이다. 다만, 데이터를 읽기 위해 걸어놓은 lock은 다른 reader 프로세스가 왔을 때 같이 읽을 수 있게 해주어야 한다.
- readcount 변수 : reader가 몇명인지를 나타내는 변수, 공유 변수(모든 reader가 건들 수 있다)
- 최초의 reader프로세스가 readcount변수를 1 증가시켜놓은 상황에서 다른 reader가 들어왔을 때 readcount가 1인지 혹은 1 보다 큰지에 따라 lock이 걸려 있는 상황인지 아닌지를 판단할 수 있게 된다. readcount가 1보다 큰 경우 나중에 도착한 프로세스는 lock을 추가적으로 걸지 않고 그냥 데이터 읽는 작업을 수행하면 된다.
- mutex : readcount라는 공유 변수를 위한 lock
- 다른 프로세스들이 다 읽고 나가고, 만약 마지막으로 나가는 프로세스라면 readcount가 0이 될 것. 그렇다면 db에 대한 lock을 풀어주어야 한다. (V(db))
- 공유 데이터
    - DB자체
    - readcount : 현재 DB에 접근 중인 reader의 수
- Synchronization variables
    - mutex : 공유 변수인 readcount에 접근하는 코드(critical section)의 mutual exclusion 보장을 위해 사용
    - db : reader와 writer가 공유 DB 자체를 올바르게 접근하게 하는 역할(DB에 대한 lock을 거는 역할)
- 그렇다면 writer는 reader 프로세스들이 모두 데이터를 읽고 모두 다 나갈 때까지 계속해서 기다려야 하는건가?
    - 그렇다. writer의 입장에서는 starvation 현상이 발생한다.
    - 그러나 이를 해결할 수 있는 방법이 있다. Queue에 우선순위를 두어 지나치게 늦게 들어온 reader가 먼저 읽는 작업을 하게 하지 않고 writer가 데이터를 쓸 수 있게 할 수도 있다.

### Dining-Philosophers Problem - 식사하는 철학자 문제


- 원탁에 철학자 5명이 앉아있다. 5명의 철학자는 각자 철학적인 생각을 하거나 배가 고파지면 밥을 먹는 일을 수행한다.
- 5명의 철학자는 생각하는 시간과 밥을 먹는 주기가 각각 다르다.
- 배가 고파지면 자신의 왼쪽과 오른쪽에 있는 젓가락을 잡아서 밥을 먹는다.
- 배가 불러지면 다시 젓가락을 놓고 생각을 하게 된다.
- 밥을 먹을려면 왼쪽과 오른쪽에 있는 젓가락 두 개를 모두 잡아야 한다.
- 각각의 젓가락은 모두 1로 초기화 되어 있다.  ⇒ 동시에 두 명의 사람이 젓가락을 잡을 수 없다.
- 문제점
    - 데드락의 가능성이 있다.
    - 데드락 : 더이상 아무것도 진행이 되지 않고 막혀 있는 상황
    모든 5명의 철학자가 동시에 배가 고파져서 왼쪽 젓가락을 모두 잡으면 오른쪽 젓가락을 절대 잡을 수 없게 된다.
    - 모든 철학자는 어느 쪽이든 젓가락을 잡는 순간 밥을 먹지 않는 이상 놓지 않는다.
- 해결 방안
    - 4명의 철학자만이 테이블에 동시에 앉을 수 있게 제한한다.
    - 젓가락을 두개 모두 잡을 수 있는 상황에서만 젓가락을 잡을 수 있게 한다.
    - 비대칭 : 짝수 철학자는 왼쪽 젓가락부터 잡도록 하고 홀수 철학자는 오른쪽 젓가락부터 잡도록 한다. 즉, 나란히 앉아 있는 철학자 중 한명이 둘 사이의 젓가락을 먼저 잡았을 경우 나머지 젓가락 한 쪽도 잡을 수 있게 하는 방법
- 2번 해결방안에 대한 코드


- 세마포어의 원리에 맞게 잘 짜여진 코드는 아니다.
- 세마포어는 process synchronization에 대한 문제를 프로그래머 입장에서 쉽게 해결할 수 있게 하기 위한 방법이다. 이러한 방법 중 하나에 세마포어 말고도 모니터 라는 것이 더 있다. 모니터는 세마포어를 더 쉽게 사용할 수 있도록 만들어 놓은 것인데 식사하는 철학자에 대한 2번 해결 방법에 대한 코드는 원래 모니터로 잘 짜여진 코드이다. 위의 코드는 이를 세마포어 버전으로 억지로 바꾸어 놓은 것이기 때문에 모니터 코드를 잘 이해하는 것이 더 중요하다.

위 코드 해설 강의에서 다시 보기

## Monitor

### 세마포어의 문제점

- 문제가 생겼을 때 버그를 잡기가 쉽지 않다.
- 한번의 실수가 모든 시스템에 치명적인 영향을 미친다.
critical section에 들어가기 전에 P를 하고 빠져나올 때 V 연산을 해야 하는데 만약 코드 상의 실수가 있어 들어가기 전에 V를 해버린 경우 동시에 P와 V가 진행되어 버린다. ⇒ Mutual Exclusion이 깨진다.
- P가 완료된 이후 V가 실행되어야 하는데 P를 또 해버린 경우 영원히 이 상황을 빠져나갈 수 없는 데드락 상태에 부딪히게 된다.

### 정의

- 프로그래밍 언어 차원에서 동기화 문제를 해결하는 high-level synchronization constructor라고 할 수 있다.
- 공유 데이터를 접근하기 위해서는 모니터라고 정의된 내부의 프로시져를 통해서만 가능하도록 만들어 놓은 것이다.


### 특징

- 모니터는 원천적으로 내부에 있는 프로시져는 동시에 여러 개가 실행이 되지 않도록 통제를 하는 권한을 제공한다. 이로 인해, 프로그래머 입장에서 lock을 걸 필요가 없게 된다. (세마포어에서는 프로그래머가 항상 P연산을 통해 공유 자원에 lock을 걸어주어야 했다.)
- 모니터에는 하나의 프로세스만이 접근할 수 있다.
- 모니터 내부에 공유 데이터에 대한 선언을 한 뒤, 공유 데이터를 접근하기 위한 프로시져들은 모니터 내부 함수로 구현해놓는다.
- 세마포어에서 자원의 갯수는 세어야 했다. (자원이 있어야 접근할 수 있게 하고 자원이 없으면 기다리게 하는 장치) 이는 모니터에도 필요한데 모니터에서는 condition이라는 변수를 사용한다.
- Condition Variable(예. x, y)은 wait와 signal 연산에 의해서만 접근이 가능하다.
    - x.wait();
        - x.wait()을 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke하기 전까지 suspend된다.
        - 기다리면서 잠들게 한다.
    - x.signal();
        - x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다. suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.
        - 줄서서 잠들어 있는 프로세스를 깨워준다.

### Producer-Consumer problem의 모니터 버젼 코드


# 프로세스 동기화 = Concurrency Control(병행 제어)

- 동시 실행 시에 문제가 생기지 않도록 하는 것
- 이를 위한 방안 중 프로그래머가 할 수 있는 것에는 세마포어와 모니터가 있다.
- 세마포어의 경우 P연산과 V연산을 통해 프로세스 동기화를 할 수 있는 방법을 프로그래머에게 알려주고 이를 통해 동기화를 하는 것이다.
- 반면 모니터는 프로그래밍 언어 차원에서 공유 데이터에 동시 접근하는 문제를 모니터가 저절로 해결해줌으로써 프로그래머의 부담을 줄여주었다.
- 공유 데이터를 접근할 때는 접근하는 코드가 있을 텐데 이를 모니터 안에 공유 데이터와 접근 코드를 정의해서 프로세스가 공유 데이터를 접근하고자 할 때 모니터 안에 정의된 코드를 이용해서만 접근할 수 있도록 만들어 놓았고 만약 다수의 프로세스가 공유 데이터에 접근하게 될 경우 모니터가 이러한 상황을 막는다. 즉, 모니터 안에서 코드를 수행하는 프로세스는 오직 하나만 있도록 한다.
- 만약 모니터 내부에 코드를 실행중인 프로세스가 이미 있다면 다른 프로세스는 모니터 내부에 접근하지 못하게 된다. 다른 프로세스는 모니터 내부에 활성화된 프로세스의 갯수가 0이 될 때 모니터에 접근할 수 있게 된다.
- 모니터에서는 lock을 걸고 푸는 과정이 원칙적으로 필요 없게 된다. ⇒ 프로그래머의 부담이 줄어든다.
- 모니터의 Condition variable
    - 세마포어에서처럼 값을 갖거나 갯수를 세는 용도가 아닌 어떤 프로세스를 잠들게 하고 줄 세우기 위한 변수이다.
- 세마포어와 모니터는 목적부터 다르다. 세마포어는 자원을 획득하기 위한 것이고 모니터는 동시 접근을 모니터 차원에서 제한해준다.

### 식사하는 철학자 문제의 모니터 코드

- state : 공유 변수 ⇒ lock&unlock 필요 없다.
