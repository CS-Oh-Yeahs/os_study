# 운영체제 스터디 OS오예스 (2022-03-30 SUN 📚)

## Process Synchronization
> *cf) Process Synchronization 프로세스 동기화 = Concurrency Control 병행제어*

### 📂 Classical Problems of Synchronization 
#### 1️⃣ Bounded-Buffer Problem (Producer-Consumer Problem)
- Producer vs Consumer 다대다 상황
  - 생산자는 공유 버퍼에 데이터를 만들어서 집어넣는 역할
  - 소비자는 데이터를 꺼내가는 역할
- **공유 버퍼**이기 때문에
  - 둘 이상의 생산자가 비어있는 동일 버퍼에 동시에 데이터를 만들 경우 문제
  - 또는 둘 이상의 소비자가 동일 버퍼의 데이터를 동시에 꺼내갈 경우 문제
- **유한한 버퍼**이기 때문에
  - 생산자 입장에서 버퍼가 다 채워진 상태에서 소비자의 요청은 없고 계속 데이터를 집어넣고자 할 경우 비어있는 버퍼 자원이 없는 문제
  - 또는 소비자 입장에서 버퍼가 비어있는 상태에서 생산자의 요청은 없고 계속 데이터를 꺼내가고자 할 경우 데이터가 들어있는 버퍼 자원이 없는 문제
- **Semaphore의 역할**
  - **Mutual Exclusion** 👉 Binary Semaphore로 **공유 버퍼 전체에 대해 lock-unlock을 통해 배타적 접근을 가능하게 하는 역할**
  - **Resource Count** 👉 Integer Semaphore로 **가용 자원의 개수 (남은 full/empty 버퍼의 개수)를 세는 역할**
```c
semaphore full = 0, empty = n, mutex = 1;

// Producer
do {
  produce an item in x
  ...
  P(empty);
  P(mutex);
  ...
  add x to buffer
  ...
  V(mutex);
  V(full); // 자원 반납, 소비자 입장에서의 자원인 full 버퍼의 개수 1 증가시켜줌
  
} while (1);

// Consumer
do P
  P(full);
  P(mutex);
  ...
  remove an item from buffer to y
  ...
  V(mutex);
  V(empty); // 자원 반납, 생산자 입장에서의 자원인 empty 버퍼의 개수 1 증가시켜줌
  ...
  consume the item in y
  ...
} while (1);
```

#### 2️⃣ Readers and Writers Problem
- 읽는 프로세스 vs 쓰는 프로세스
- 한 프로세스가 공유 데이터(DB)에 write 중일 때 다른 프로세스는 접근할 수 없음
- 단, read는 동시에 여러 프로세스가 가능!
- Reader가 접근 중일 경우에도 Writer가 접근해서는 안 되기 때문에 **lock 자체는 걸어야하지만 다른 Readers는 접근 가능하게** 해주어야 함!

🚨 **Writer가 Starvation을 겪을 수 있는 문제**  
👉 Reader는 Writer보다 조금 늦게 도착하더라도 먼저 읽을 수 있기 때문

```c
int readcount = 0; // 현재 DB에 접근 중인 readers 프로세스 수  
DB 자체;
semaphore mutex = 1, db = 1; // binary semaphore 두개

// Writer
P(db);
...
writing DB is performed
...
V(db);

// Reader
P(mutex); // mutex는 readcount를 위한 lock, readcount 값 변경 시에도 동기화 문제가 발생할 수 있기 때문
readcount++;
if (readcount == 1) P(db); // readcount 를 1로 만든 프로세스가 lock 설정함
V(mutex);
...
reading DB is performed
...
P(mutex);
readcount--;
if(readcount==0) V(db); enable writer // 마지막으로 읽고 나가는 프로세스가 DB에 설정한 lock을 풀어줌
V(mutex);
```

#### 3️⃣ Dining-Philosophers Problem
```c
semaphore chopsticks[5]; // initially all values are 1

//Philosopher i
do {
  P(chopstick[i]);
  P(chopstick[(i+1)%5]);
  ...
  eat();
  ...
  V(chopstick[i]);
  V(chopstick[(i+1)%5]);
  ...
  think();
  ...
} while (1);
```

🚨 **Deadlock의 가능성**  
👉 철학자 5명이 동시에 왼쪽 젓가락을 잡았을 때 아무도 식사가 끝나지 않는 이상 들고 있는 하나의 젓가락을 내려놓지 않아서 발생하는 문제
- Solution
  - 5개의 자리 중 **4명의 철학자만이 테이블에 동시에 앉을 수 있도록** 함
  - **젓가락 두 개를 모두 잡을 수 있을 때에만** 젓가락을 잡을 수 있게 함
  - **비대칭**으로 짝수 철학자는 왼쪽 젓가락부터, 홀수 철학자는 오른쪽 젓가락부터 잡도록 함

```c
// 세마포어는 주로 자원의 개수를 세고 초기값을 1로 하지만
// 이 코드에서는 0으로 초기화하고 특정 조건 만족 시에만 1로 얻게 된다는 것이 특이한 점
enum {thinking, hungry, eating} state[5];
semaphore self[5] = 0; // 젓가락을 두 개 다 잡을 수 있는 권한
semaphore mutex = 1; // state 변경에 대한 lock

void test(int i) {
  if (state[(i+4)%5] != eating && state[i] == hungry && state[(i+1)%5] != eating) {
    state[i] = eating;
    V(self[i]);
  }
}

void pickup(int i) {
  P(mutex);
  state[i] = hungry;
  test(i);
  V(mutex);
  P(self[i]);
}

void putdown(int i) { // 젓가락을 내려놓을 때 인접 철학자들을 테스트 해줌
  P(mutex);
  state[i] = thinking;
  test((i+4)%5);
  test((i+4)%5);
  V(mutex);
}

do {
  pickup(i);
  eat();
  putdown(i);
  think();
} while (1);
```
   
### 📂 모니터
- high-level synchronization construct
- 동시 수행 중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장
- **공유 데이터 및 공유 데이터 접근 프로시저를 모니터 내부에 정의**
- **모니터에 대한 동시 접근을 허용 ❌ 프로그래머가 lock을 걸어줄 필요 ❌**
- 프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해 condition variable 사용 (wait, signal 연산에 의해서만 접근 가능)

> Semaphore 문제점  
> 👉 코딩하기 힘들다, 정확성의 입증이 어렵다, 자발적 협력이 필요하다, 문제 발생 시 버그를 잡기 어렵다 등
