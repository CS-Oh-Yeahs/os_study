# 🔷메모리 관리

## 1️⃣ 메모리의 종류

### 논리적 주소

- 프로세스마다 독립적으로 갖는 주소 공간
- 각 프로세스마다 0번지부터 시작한다.
- CPU가 보는 주소

### 물리적 주소

- 물리적 메모리에 프로세스가 실제로 올라가는 위치

### cf) Symbolic Address

- 프로그래머 입장에서 사용하는 변수와 같은 주소 체계
- 컴파일 시, 숫자 주소로 변환된다.

## 2️⃣ 주소 바인딩

- 어떤 프로그램의 물리적 메모리 주소를 결정하는 것

### 컴파일 타임 바인딩

- 물리적 메모리 주소가 컴파일 시에 알려지는 것
- 시작 위치를 변경하고자 할 때에는 다시 컴파일을 해야한다.
- 컴파일러는 절대 코드를 생성한다.
- 현대의 시스템에서는 더이상 사용하지 않는다.

### 로드 타임 바인딩

- 로더의 책임하에 물리적 메모리 주소를 부여
- 컴파일러가 재배치가능코드를 생성한 경우 가능하다.

### 런타임 바인딩

- 프로그램이 실행된 이후에도 프로세스의 메모리 상의 물리적 위치가 달라질 수 있는 방법
- CPU가 주소를 참조할 때마다 바인딩을 점검하게 된다. (주소 매핑 테이블)
- MMU와 같은 하드웨어적인 지원이 필요하다.

![runtime binding](https://user-images.githubusercontent.com/90598889/161931422-d1d18ec9-609a-4bfd-aff2-e93f6f535aa3.jpg)

- CPU는 컴파일 이후 생기는 실행 파일 내의 코드들의 논리적 주소들을 참조하면서 로직을 수행할 수 있다. 따라서 바인딩 기법이 달라져도 실행 파일의 코드들의 논리적 주소들은 바뀌지 않으며 단지 물리적 메모리 내의 시작 주소만이 바뀔 뿐이다. 만약 프로세스 내의 논리적 주소들을 바꾸고자 할 경우, 컴파일을 다시 해야한다.

### MMU(Memory-Management Unit)

- 논리적 주소를 물리적 주소로 매핑해주는 하드웨어
- relocation register, limit register라는 두개의 레지스터를 사용하여 주소 변환을 한다.

![MMU 개요](https://user-images.githubusercontent.com/90598889/161931704-ea597fba-3fd2-4f0a-8e1d-0ff40fa89c73.jpg)

![MMU](https://user-images.githubusercontent.com/90598889/161931527-c665ef15-41e1-4fb6-a69f-c4fa1408f371.jpg)

- 베이스 레지스터에 프로그램의 물리적인 시작 위치를 저장해놓는다.
- 프로세스의 최대 크기를 limit register에 저장하여 다른 프로세스의 주소 공간을 침범하지 않도록 예방한다.
- 사용자 프로그램
    - 논리적 주소만을 다룬다.
    - 실제 물리적 주소를 볼 수 없으며 알 필요도 없다.

## 3️⃣ 관련 용어

### 동적 로딩(Dynamic Loading)

- 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 로드하는 것
- 메모리 활용도가 향상된다.
- 프로그램 중 상당 부분은 자주 사용되지 않는다. 가끔씩 사용되는 많은 양의 코드가 있을 경우 유용하다.
    
    예) 오류 처리 루틴
    
- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하다. 운영체제는 라이브러리를 통해 지원이 가능하다.
- 운영체제의 페이징 기법과는 다른 의미이다.

### 중첩(Overlay)

- 메모리에 프로세스의 부분 중 실제 필요한 정보만을 올리는 것
- 프로세스의 크기가 메모리보다 클 경우 유용하다.
- 운영체제의 지원없이 사용자에 의해 구현된다.
- 작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현했다. ⇒ 매우 복잡하다.

### 스와핑(Swapping)

- 프로세스를 일시적으로 메모리에서 하드디스크의 backing store로 쫓아내는 것

*Backing store(swap area) : 디스크라고 불리며 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간을 말한다.

- Swap in
    - 컴파일 타임 바인딩 혹은 로드 타임 바인딩에서는 원래 메모리 위치로 스왑인 해야한다. 
    ⇒ 스와핑이 효율적으로 이루어지지는 않는다.
    - 런타임 바인딩에서는 추후 빈 메모리 영역 아무 곳에나 스왑인 할 수 있다.
- Swap out
    - 일반적으로 중기 스케쥴러(스와퍼)에 의해 스왑 아웃될 프로세스가 선정된다.
    - 우선순위가 낮은 프로세스를 스왑 아웃 시킨다.

⇒ 스왑에 드는 시간은 대부분 프로세스를 이동시키는 시간이다.

- 최근에는 스왑 아웃이라는 용어가 페이징 기법에서 프로세스의 일부 페이지가 메모리에서 쫓겨났을 경우를 지칭할 때에도 사용된다.

### 동적 연결(Dynamic Linking)

- Linking : 컴파일된 실행파일과 라이브러리들을 연결하는 것
- 연결(linking)을 실행 시간까지 미루는 기법
- 라이브러리가 프로그램이 실행될 때 연결된다.
- 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위해 stub라는 작은 코드를 둔다.
- 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 이동하고 없다면 디스크에서 읽어오게 된다.
- 운영체제의 도움이 필요하다.
- 동적 연결을 해주는 라이브러리를 shared library, DLL(windows OS에서)이라고 부른다.

## 4️⃣ 메모리 할당

### 물리적 메모리의 구성

- OS 상주 영역
    - 낮은 주소의 영역을 사용
- 사용자 프로세스 영역
    - 높은 주소의 영역을 사용

### 사용자 프로세스 영역의 할당 방법

### 연속 할당(Contiguous allocation)

- 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것
    
    ### 고정분할(Fixed Partition allocation)
    
    - 물리적 메모리를 몇 개의 영구적 분할로 나누어 놓는 방식
    - 외부조각
        - 프로그램의 크기보다 메모리의 분할 공간이 작을 경우 발생
        - 프로그램에 할당되지 못하는 메모리의 공간
    - 내부조각
        - 프로그램의 크기보다 메모리의 분할 공간이 클 경우 발생하는 잉여 공간
        - 프로그램에 할당은 되지만 사용되지 않는 낭비되는 공간
    
    ### 가변분할(Variable partition allocation)
    
    - 프로그램의 크기를 고려해서 메모리를 할당하는 방식
    - 프로그램들의 크기가 균일하지 않기 때문에 실행되던 프로그램이 종료될 경우 사용되지 않는 메모리 공간인 ‘외부조각’이 발생할 수 있다.
    - 내부조각은 발생하지 않는다.
    - **Hole**
        - 실행되던 프로그램이 종료될 경우 일시적으로 생기는 가용 메모리 공간
        - 운영체제는 할당된 공간과 가용 공간에 대한 정보들을 유지해야 한다.
    - 동적 메모리 할당 문제
        - 특정 사이즈의 프로세스를 할당할 가장 적절한 hole을 찾는 문제
        - **최초 적합(First Fit)**
            - 최초로 찾아지는 hole에 할당하는 방법
        - **최적 적합(Best Fit)**
            - 특성 사이즈 이상인 hole들 중 가장 작은 hole에 할당하는 방법
            - hole들의 크기를 모두 탐색한 후 할당해야 한다.
        - **최악 적합(Worst Fit)**
            - 프로세스의 크기를 고려하지 않고 가장 큰 hole에 할당하는 방법
            - hole들의 크기를 모두 탐색한 후 할당해야 한다.
            - 가장 큰 hole이 적합한 다른 프로세스가 있을 수 있으므로 효율적이지 않은 방법이다.
        
        ⇒ 실험적으로 최초적합 혹은 최적적합 방식이 속도와 공간 이용률 측면에서 효과적이다.
        
    - **Compaction**
        - 외부 조각 문제를 해결하는 방법
        - 사용중인 메모리 영역을 한군데로 몰고 hole들을 한 곳으로 몰아 큰 block으로 만드는 방법
        - 메모리를 사용중인 전체 프로세스들을 바인딩 해야하므로 비용이 매우 많이 소요되는 방법이다.

### 불연속 할당(Noncontiguous allocation)

- 하나의 프로세스가 메모리의 여러 영역에 분산되어 적재되도록 하는 것
    
    ### 페이징 기법(Paging)
    
    - 프로세스의 주소 공간을 같은 크기로 자른 페이지들을 같은 크기로 잘라놓은 물리적 메모리의 페이지 프레임에 각각 할당하는 방법
    - 일부는 백킹스토리지에, 일부는 물리적 메모리에 저장되므로 페이지들이 불연속적으로 저장된다.
    - 주소 변환을 페이지 단위로 해야하기 때문에 주소 바인딩이 더욱 어려워진다.
    - 운영체제는 비어있는 페이지 프레임을 관리하게 된다.
    - 주소 변환이 페이지 단위로 이루어져야 하기 때문에 페이지 테이블을 이용한다.
    - 외부조각은 발생하지 않지만 내부 조각은 발생할 가능성이 있다. 
    (프로세스의 크기가 페이지*n 이 되지 않을 수도 있기 때문)
    - **페이지 테이블**
        - 논리적 주소들이 물리적 테이블의 프레임의 어떤 곳에 올라가 있는지에 대한 정보를 담고 있는 테이블
            
            *테이블 : 인덱스를 이용해서 정보에 곧바로 접근할 수 있는 자료구조
            
        - 주소 변환 시, 페이지 내의 offset 부분은 바뀌지 않는다.
        - 페이지 테이블의 용량은 굉장히 크고 프로세스마다 별도의 페이지 테이블이 존재해야 한다. 따라서 메인메모리에 상주한다.
    - 기존에 존재했던 base register와 limit register는 각각 PTBR(Page-table base register-페이지 테이블을 가리킴), PTLR(Page-table length register-테이블 크기를 보관) 로서의 역할을 하게 된다.
    - 페이지 테이블을 접근하기 위해 메모리에 접근 1번, 메모리 내의 데이터나 코드에 접근하기 위해 메모리에 접근해야하므로 페이징 기법에서는 총 2번의 메모리 접근이 필요하다.
    - 그러나 매번 2번씩 메모리를 접근하게 되면 시간이 많이 소요되므로 TLB라는 별도의 하드웨어를 사용한다.
    - **TLB**
        - 주소 변환을 위한 캐시 메모리
        - 페이지 테이블에서 빈번히 사용되는 일부 엔트리를 캐싱하고 있다.
        - 메인 메모리보다 접근 속도가 빠르다.
        - 페이지 테이블을 통한 주소 변환 전에 TLB에 먼저 접근하여 해당 주소가 TLB에 저장되어 있다면 TLB에서 주소를 가져다 쓴다.
        - 논리적인 페이지 번호인 p와 p에 대한 주소 변환값인 f를 쌍으로 보관하고 있다.
        - 주소 변환을 위해서는 TLB 전체를 모두 탐색해보아야 한다.
        ⇒ 탐색에 시간이 오래 걸리므로 associative register를 이용하여 병렬 탐색이 가능하도록 한다.
        - 만약 TLB에 주소가 없다면 페이지 테이블을 통해 주소를 변환한다.
        - 페이지 테이블처럼 프로세스마다 TLB의 정보도 달라야 한다. 
        ⇒ 컨텍스트 스위치가 일어날 때 flush 된다.
    - **메모리 접근에 소요되는 시간**(공식)
        
        $EAT = (1+ε)α +(2+ε)(1-α)$
        
    
    ### 세그멘테이션 기법(Segmentation)
    
    - 프로세스의 주소 공간을 같은 크기가 아닌 코드, 데이터, 스택과 같이 의미 있는 단위로 자르는 기법
    - 코드 세그먼트, 데이터 세그먼트, 스택 세그먼트로 잘라 물리적 메모리의 각각 다른 위치에 올려놓는다.
    - 주소 공간의 크기가 균일하지는 않다. 이로 인해 동적 메모리 할당 문제가 발생할 수 있다.
    
    ### 페이지드 세그멘테이션 기법(Paged Segmentation)
