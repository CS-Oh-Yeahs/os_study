- **2단계 페이지 테이블**
    - 사용하는 이유 : 페이지 테이블을 위한 공간이 줄어들기 때문
    - 현대의 컴퓨터는 메모리의 주소 체계가 굉장히 크다.
        - 32 bit 주소 체계를 사용할 경우
            - 메모리 주소는 2^32 (4GB) 까지 표현할 수 있다.
    - 프로그램의 주소 공간에서 사용되는 공간은 일부분뿐이다. 그런데 주소 공간은 배열 구조로 되어 있으므로 인덱스를 통해서 접근하려면 사용되지 않는다고 해서 해당 공간을 빼버릴 수는 없다. 따라서 페이지 테이블 엔트리는 모두 만들어져야만 한다. 이렇게 되면 공간 낭비가 심해진다.
    - 주소 변환
        - ㄹㅇㄴ
    - 안쪽 페이지 테이블의 크기는 테이블의 크기와 같다.
  
- 다단계 페이지 테이블
    
    - 위의 수식 계산을 통해 TLB를 통해서 주소 변환을 한다면 다단계 테이블이 주소 변환을 하는 데에 큰 시간이 걸리지 않음을 알 수 있음.
- 페이지 테이블에 존재하는 Bit들
    - Valid / Invalid Bit
        - 프로세스 주소 공간을 일정 크기로 자른 페이지들 중에서는 사용되지 않는 페이지들이 있으나 페이지 테이블에는 이 페이지들에 대한 엔트리가 모두 존재한다. 이들 중 프레임에 올라가있는 엔트리를 Valid/Invalid Bit를 통해 표시함으로써 → 이후 부터 모르겠음. 주소 변환을 보다 빠르게 처리할 수 있도록 한다...?()        
        - Protection Bit
            - 페이지 테이블은 각 프로세스마다 하나씩 존재하는 것이기 때문에 다른 프로세스의 페이지 테이블에 접근하지 않기 위해 존재하는 Bit는 아니다.
            - 해당 Bit는 어떤 연산에 대한 접근 권한인지를 나타내준다. 어떠한 페이지에 대해 읽기 권한이 있는지, 쓰기 권한이 있는지에 대해 표시하는 bit이다.
            - 예를 들어, 프로세스의 주소 공간에서 코드 섹션에 해당하는 페이지들의 경우 ‘read-only’ 모드로만 접근이 가능하다.
- Inverted Page Table
    
    - 페이지 테이블은 그 크기가 매우 큰데 이러한 설계를 완전히 뒤집어서 생각해 놓은 테이블
    - 시스템 안에 페이지 테이블이 딱 하나만 존재한다.
    - 페이지 테이블 내의 엔트리들은 물리적 메모리의 프레임 갯수와 일치한다.
    - 페이지 테이블 내의 첫번째 엔트리에는 물리적 메모리의 첫번째 프레임에 존재하는 논리적 주소의 페이지 번호가 담겨있다.
    - 그런데 주소 변환은 논리적 주소를 물리적 주소로 바꾸는 것인데 위의 테이블은 그 반대이다.
    - 페이지 번호가 주어지면 엔트리를 모두 뒤져서 논리적 주소를 찾아야만 한다.
    - 페이지 테이블에는 논리적인 페이지 번호만 저장하는 것이 아닌, 페이지 번호 p가 어떤 프로세스의 페이지 아이디인지 프로세스 아이디도 함께 저장해야한다. (페이지 테이블이 오직 하나 뿐이기 때문)
    - Associative register라는 별도의 하드웨어에 엔트리 정보를 넣어두고 탐색 시간을 줄이도록 조치한다.
- 공유 페이지
    - 물리적 메모리에 프로세스끼리 공유가 가능한 코드들(Pure Code=Re-entrant Code=Shared Code)을 물리적 메모리에 한번만 올려두고 같은 프레임으로 매핑시킨다.
    - shared code가 만족해야 하는 조건
        - read-only 로 세팅해야 한다.
        - 모든 코드가 동일한 논리적 주소에 위치해야 한다.
    - IPC(Inter-Process Communication)과는 다르다. shared code는 오로지 read만 가능하다.

### 세그멘테이션 기법(Segmentation)

- 프로세스의 주소 공간을 같은 크기가 아닌 코드, 데이터, 스택과 같이 의미 있는 단위로 자르는 기법
- 코드 세그먼트, 데이터 세그먼트, 스택 세그먼트로 잘라 물리적 메모리의 각각 다른 위치에 올려놓는다.
- 주소 공간의 크기가 균일하지는 않다. 이로 인해 동적 메모리 할당 문제가 발생할 수 있다.
- 아키텍쳐
    - 논리적 주소는 세그먼트번호와 오프셋(세그먼트 안에서 얼마나 떨어져 있는지)로 구성된다.
    - 각 세그먼트 별로 주소 변환을 하기 위한 세그먼트 테이블이 있다.
    - 레지스터가 두 개 지원되는데 STBR-세그먼트 테이블의 시작 위치를 표시 와 STLR(세그먼트 테이블의 엔트리의 갯수 즉, 테이블의 길이)로 구성된다.
- 주소 변환 과정 
    - CPU가 논리적 주소를 주면 이를 세그먼트 번호와 오프셋(해당 요소가 세그먼트로부터 얼마나 떨어져 있는지를 의미)으로 나눈다.
    - 엔트리 갯수는 세그먼트의 갯수
    - 세그먼트 테이블로 이동해서 테이블의 시작 위치에서 세그먼트 번호만큼 떨어진 엔트리로 이동하면 해당 세그먼트가 물리적 메모리의 어떤 위치에 올라가있는지를 가지고 있다.
    - 페이징 기법과는 다르게 엔트리에 두 가지 정보를 가지고 있다.
        - 물리적 메모리 상의 시작 위치
        - limit : 세그먼트의 길이
        
        ⇒ 페이징 기법에서는 페이지의 길이가 모두 동일했지만 세그멘테이션 기법에서는 세그먼트의 길이가 균일하지 않을 수 있기 때문
        오프셋의 크기도 페이징 기법에서는 페이지의 길이로 자동으로 정해지게 된다.
        
    - 주소 변환을 할 때 논리적 주소에서 세그먼트 번호가 세그먼트 테이블의 STLR의 크기보다 크다면 잘못된 요청이므로 trap이 걸린다.
    - 세그먼트의 길이보다 오프셋의 값이 더 크지는 않은지 확인하고 만약 더 크다면 trap이 걸리게 된다.
    - 정상적으로 주소 변환이 되는 경우 세그먼트의 시작 위치 값에 오프셋을 더해서 주소가 변환되게 된다.
    - 세그먼트의 길이는 오프셋으로 표현할 수 있는 범위 내에 속해야 한다.
    - 페이징 기법에서는 시작 주소가 프레임 번호로 주어지면 되지만 세그멘테이션에서는 세그먼트의 크기가 다 다르기 때문에 어떤 세그먼트가 어디에서 시작이 되는지 정확한 byte 단위로 표시해주어야 한다.
    - 앞서 연속할당 기법에서 중간중간 낭비되는 메모리 공간인 hole들이 생겼던 것처럼 세그멘테이션 기법 또한 세그먼트의 크기가 균일하지 않으므로 이러한 현상이 생길 수 있다.
    - 장점의 경우 의미단위로 일을 하는 것이기 때문에 protection의 경우 read-only, read와 같은 권한을 의미 단위로 하게 되므로 페이징 기법에서보다 더욱 관리가 쉽다.
    - 예시
      - 세그먼트의 경우 페이징 기법과는 달리 프로세스가 쪼개진 갯수가 적다. 따라서 실제로 페이징 기법은 테이블을 위한 메모리 낭비가 굉장히 심하다.
      - 페이징의 경우 물리적인 메모리의 낭비 조각이 발생하지 않지만 세그멘테이션 기법의 경우 물리적인 메모리의 낭비 조각이 발생하여 allocation 문제인 외부 조각이 발생하게 될 수 있다.
- 세그먼트 공유
    - editor라는 코드 부분을 두 프로세스가 공유할 수 있다. 이를 위해 세그먼트 번호는 두 세그먼트 테이블에서 모두 0으로 동일해야 한다.
    - 공유할 수 없는 세그먼트는 private segment로 메모리에 별도로 올린다.

### 페이지드 세그멘테이션 기법(Paged Segmentation)

- 페이징 기법과 세그멘테이션 기법의 혼합
- 세그먼트 하나가 여러 개의 페이지로 구성된다.
- 먼저, 세그먼트에 대한 주소 변환을 하게 되므로 각 프로세스가 갖는 논리적 주소는 세그먼트 번호와 오프셋으로 구성된다.
- 다음으로 세그먼트 테이블에서 페이징 기법이 적용되어, 세그먼트가 여러 개의 페이지 단위로 쪼개지게 되고 각각의 세그먼트마다 페이지 테이블이 생기게 된다.
- 페이지 테이블의 엔트리의 경우 세그먼트의 길이에 따라 달라지게 되고 논리적 주소에서 세그먼트 오프셋의 앞부분을 페이지 번호로 사용하고 뒷부분을 페이지 오프셋으로 사용하여 페이지 테이블의 시작 위치와 각 번호마다 오프셋을 더해 엔트리를 형성하고 이를 물리적 메모리 주소로 매핑하게 된다. 결론적으로 각 페이지별로 물리적 메모리에 올라가게 된다.
- 세그멘테이션의 단점이었던 외부조각이 생기지 않게 된다.
- protection과 sharing의 경우 세그먼트 테이블 차원에서 적용된다.
- 원래 세그멘테이션 기법 홀로만 쓰이지는 않는다.

## 그렇다면 주소 변환에 있어서 운영체제의 역할은?

⇒ 없다. 주소 변환은 모두 하드웨어가 담당하는 역할이고 이 과정에서 운영체제의 역할은 없다. 운영체제는 I/O 장치에 접근해야 할 경우 끼어들게 된다. 따라서 이 챕터에서 운영체제의 역할을 없었다.
운영체제 또한 하나의 프로그램이므로 CPU를 점유해서 프로세스를 수행하는 다른 프로그램과 크게 다르지 않다.
