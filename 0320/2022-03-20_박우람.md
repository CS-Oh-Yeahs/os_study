# os_study 2주차 - 02-1 

## 1. 프로세스와 관련한 시스템 콜

✔️fork() 

- create a child (copy)

✔️exec()

- overlay new image

✔️wait()

- sleep until child is done

✔️exit()

- frees all the resources, notify parent

## 2. 프로세스 생성 (Process Creation)

‼️  ***Copy-on-wirte(COW)*** 

- 자원의 내용이 변경될 때 메모리 영역을 복제하고 변경되지 않을 경우에는 부모 프로세스의 자원을 공유한다.

✔️  부모프로세스(Parent process)가 자식 프로세스(chlidren process) 생성

✔️ 프로세스의 트리(계층 구조) 형성

✔️ 프로세스는 자원을 필요로 함

- 운영체제로부터 받는다
- 부모와 공유한다.

✔️ 자원의 공유

- 부모와 자식이 모든 자원을 공유하는 모델
- 일부를 공유하는 모델
    - 보통은 공유하는 모델보다 공유하지않는 모델이 대부분이다.
- 전혀 공유하지 않는 모델
    - 부모와 자식 프로세스가 자원을 공유하지 않을 경우엔 자원을 두고 부모와 자식이 경쟁하게 된다.

✔️ 수행(Execution)

- 부모와 자식이 공존하며 수행되는 모델
    - 부모와 자식이 공존하며 수행되는 모델은 자식과 부모가 CPU를 획득하기 위해 경쟁하는 관계가 된다.
- 자식이 종료(terminate)될 때까지 부모가 기다리는(wait)모델
    - 자식 프로세스가 종료될 때까지 부모는 봉쇄상태에 머물러 있다가 자식프로세스가 종료된 이후에 CPU를 얻을 수 있는 권한이 생긴다.
    - 일반적인 봉쇄상태와 다르게 자원을 기다리며 줄 서 있는 것이 아니다.

✔️ 주소 공간 (Address space)

- 자식은 부모의 공간을 복사함 (binary and OS data)
- 자식은 그 공간에 새로운 프로그램을 올림

✔️ 유닉스의 예

- fork()
    - fork() 시스템 콜이 새로운 프로세스를 생성
    - 부모를 그대로 복사 (OS data execpt PID + binary)
        - 주소공간은 따로 가지고 있지만 주소공간의 내용은 동일한 내용을 갖게 된다 (문맥이 동일하다)
        - 문맥이 동일하기 때문에 부모 프로세스의 프로그램 카운터 지점부터 수행하게 된다.
    - 주소 공간 할당
    - 부모 프로세스와 다른 작업을 수행할 수 있지만, 이는 조건문에 의한 분기일 뿐 사실상 부모 프로세스와 동일한 코드의 내용을 갖는다.
- exec()
    - exec() 시스템 콜을 통해 새로운 프로그램으로 주소 공간을 덮어씌울 수 있다.
    - 부모 프로세스와 문맥이 달라지므로 부모프로세스의 실행시점부터 수행하지 않고 처음부터 실행하게 된다.

## 3. 프로세스 종료 (Process Termination)

✔️ exit()

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다(exit)
- 자식이 부모에게 output data를 보냄 (via wait)
- 프로세스의 각종 자원들이 운영체제에게 반납됨
- 명시적으로 exit()를 호출하지 않았더라도 컴파일러가 main 함수가 리턴되는 위치에 exit()를 넣어줌

✔️ abort()

- 자식이 할당 자원의 한계치를 넘어섬
- 자식에게 할당된 태스크가 더 이상 필요하지 않음
- 키보드로 kill, break를 친 경우
- 부모가 종료(exit)하는 경우
    - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.
    - 단계적인 종료

## 4. 자식 프로세스 생성

✔️ 부모 프로세스가 자식 프로세스를 생성할 때의 플로우

1. 부모 프로세스가 자식 프로세스 생성을 위해 fork() 시스템 콜을 발생시킨다.
2. fork() 시스템 콜이 발생하면 CPU의 제어권이 커널로 넘어간다.
3. 커널은 fork()를 호출한 프로세스를 복제하여 자식 프로세스를 생성한다.

> 부모 프로세스를 복제하여 생성된 자식 프로세스는 현실세계의 부모 자식과는 달리 자신을 똑닮은 자식이 아닌, 자신의 외모와 기억이 전부 동일한 복제인간을 생성하는 것과 같다.
> 
> 
>  복제된 대상은 ‘복제되었다'는 기억을 가지는 것이 아니라 부모와 마찬가지로 방금 전에 자기 자신을 ‘복제했다'는 기억을 가지게 된다. 자식 프로세스가 복제된 프로세스라는 사실을 알 수 있는 단서는 fork() 함수의 결과값이 원본 프로세스는 양수를 가지고 복제본은 0을 갖는다는 차이점이 있다.
> 

## 5. 프로세스간의 협력

> 프로세스는 각자 자신만의 독립적인 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소공간을 참조하는 것은 허용되지 않는다. 따라서 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.
> 

🤔 ***독립적인 프로세스가 서로 협력하면 프로세스 작업의 효율성이 증가할 것 같은데..?*** 

원칙적으론 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없지만, 프로세스가 협력했을 때 작업 효율이 증가할 수 있기 때문에 운영체제는 여러가지 매커니즘을 제공한다. 대표적인 매커니즘으론 IPC가 있다.

✔️  프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)

- 하나의 컴퓨터안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신
- 프로세스간의 통신과 동기화를 이루기 위한 메커니즘
- 메시지 전달 방식과 공유 메모리 방식이 있음.
    - 두 방식의 차이는 프로세스 사이에 공유 데이터를 사용하는가, 그렇지 않는가에 있다
- 메시지를 전달하는 방법
    - Massage passing
        - 커널을 통해 메시지 전달
- 주소공간을 공유하는 방법
    - Shared memory
        - 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared momory 메커니즘이 있음
    - 🤔 Thread
        - thread는 사실상 하나의 프로세스이므로 프로세스 간 협렵으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능
        

### ‼️ IPC의 메세지 전달 방식 (Massage passing)

✔️ Message system

- 프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템

✔️ Direct Communication

- 통신하려는 프로세스의 이름을 명시적으로 표시

<img width="583" alt="스크린샷 2022-03-20 오후 8 03 43" src="https://user-images.githubusercontent.com/56028408/159159351-86081a47-49b8-424c-9490-3dd586acbc92.png">


✔️ Indirect Communication

- mailbox (또는 port)를 통해 메세지를 간접 전달

<img width="583" alt="스크린샷 2022-03-20 오후 8 04 12" src="https://user-images.githubusercontent.com/56028408/159159348-1860f708-522d-487f-ab62-543c36d90581.png">

💡 **Massage passing**

> 공유데이터를 사용하지 않는 프로세스들이 메시지를 주고받으며 통신하는 방식을 사용한다. 이때 두 프로세스의 주소공간이 다르므로 메시지를 직접 전달할 수 없기 때문에 커널이 그 역할을 대신한다.
> 
> 
> 메시지 통신을 하는 시스템은 커널에 의해 send와 receive라는 두 가지 연산을 제공받게 된다. 이 두 연산을 통해 프로세스는 전달할 메세지를 운영체제에게 시스템 콜 방식으로 요청해 전달할 수 있다.
> 
> 통신하기를 원하는 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 receive()를 이용해서 메시지를 주고받게 된다.
>
