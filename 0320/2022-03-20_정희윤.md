# 🔷프로세스 관리

## 1️⃣ 프로세스 생성

### 개요

- 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성
- 이후부터는 이미 존재하는 프로세스가 다른 프로세스들을 복제 생성
- **부모 프로세스**(프로세스를 생성한 프로세스)가 **자식 프로세스**(새롭게 생성된 프로세스)를 생성
- **복제 생성**
    - 부모 프로세스의 문맥을 자식 프로세스 생성 시, 그대로 복사하는 것
- 부모 프로세스 하나가 자식을 여러 개 만들 수 있다.
⇒ 프로세스 트리 계층을 형성하게 된다.

### 프로세스의 자원 확보 방법

- 프로세스는 작업을 수행하기 위해 자원을 필요로 한다.
    - 운영체제로부터 직접 자원을 할당 받는다.
    - 부모 프로세스와 자원을 공유하는 경우도 있다.
    단, 원칙적으로는 자원을 공유하지 않는다.
        - copy-on_write(COW)기법

### 프로세스 생성 절차(Unix예시)

- 부모 프로세스의 주소 공간을 자식 프로세스가 그대로 복사한다. 
운영체제의 자원들도 똑같이 복제한다.
- 자식 프로세스은 부모 프로세스의 주소 공간, 프로그램 카운터, 레지스터 상태, PCB 및 커널스택 등 모든 문맥을 복제한다.
- 자식 프로세스는 복제된 프로세스에 새로운 프로그램을 올려 실행한다.
- 프로세스 생성 과정
    - **fork()** 라는 시스템 콜을 통해 새로운 프로세스를 생성한다.
        - 부모 프로세스의 프로그램 카운터를 그대로 복제하기 때문에 자식 프로세스는 fork() 이후의 코드부터 실행하게 된다.
        - fork()라는 함수의 return 결과값에 구분을 두어 부모 프로세스와 자식 프로세스를 구분한다.
            - 부모 프로세스 : 0이상의 양수
            - 자식 프로세스 : 0
    - **exec()** 이라는 시스템 콜을 통해 새로운 프로그램을 메모리에 올린다.
        - 자식 프로세스의 경우, exec() 이후의 코드가 실행되어 새로운 프로세스가 된다.
- 프로세스는 운영체제의 도움을 받아야지만 생성이 가능하다.
- 프로세스가 종료될 때는 **exit()**이라는 시스템 콜을 통해 종료된다.
    - 마지막 명령어 수행 후 exit() 시스템 콜을 통해 프로세스가 **자발적**으로 종료된다.
    - 명시적으로 프로그램에 적어져 있는 경우도 있고 main 함수가 명령어를 끝까지 수행한 후에 exit() 을 명령어를 생성하여 시스템 콜을 하기도 한다.
    - 운영체제는 프로세스로부터 자원을 회수하고 시스템 내에서 프로세스를 정리한다.
- 프로세스의 세계에서는 자식 프로세스가 종료된 이후 부모 프로세스가 종료되어야 한다.
- 자발적으로 프로세스가 종료되고 부모가 자식이 종료될 때까지 기다릴 경우, **wait()** 이라는 시스템 콜을 통해 자식이 부모에게 output data를 보낸다.
    - wait()은 자식 프로세스가 종료될 때까지 부모 프로세스가 기다리게 되는 시스템 콜이다.
    - 커널은 wait()시스템 콜을 호출한 프로세스를 자식 프로세스가 종료될 때까지 sleep시킨다. (봉쇄 상태)
    - 자식 프로세스가 종료되면 커널은 wait()시스템 콜을 호출한 프로세스를 깨운다. (준비 상태)
- 비자발적으로 프로세스가 종료될 때, **abort()**라는 시스템 콜을 통해 프로세스가 종료된다.
    - 부모 프로세스가 자식 프로세스를 강제로 종료시키는 것이다.
    - 강제종료가 발생하는 경우
        - 키보드로 kill, break 등을 친 경우
        - 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구할 경우
        - 자식에게 할당된 태스크가 더 이상 필요하지 않을 경우
        - 부모 프로세스가 종료되는 경우

### 프로세스 생성 과정 정리

프로세스가 fork() 시스템 콜 → CPU의 제어권이 커널에게 넘어감 → 커널이 fork()를 호출한 프로세스를 복제해 자식 프로세스를 생성 → exec() 시스템 콜을 통해 주소 공간을 완전히 새로운 프로그램으로 덮어씌움 → 새로운 프로그램 실행

- 프로세스와 관련된 **시스템 콜(특권명령)**
    - fork()
    - exec()
    - wait()
    - exit()

---

## 2️⃣ 프로세스 간 협력

### 독립적 프로세스

- 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.

### 협력 프로세스

- 운영체제가 제공하는 **프로세스 협력 메커니즘**을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다.

### IPC (Inter-process Communication)

- 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신
- 프로세스들 간의 **통신**과 **동기화**를 이루기 위한 메커니즘

### 메시지 전달 방식(Message passing)

- 프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고받으며 통신하는 시스템
- 커널을 통해 메시지를 전달 ⇒ 커널이 send와 receive라는 두 가지 연산 제공 ⇒ 두 프로세스가 커뮤니케이션 링크를 생성한 후, 시스템 콜 방식으로 운영체제에 메세지 전달
    - **직접 통신(Direct Communication)**
        - 메시지의 전송 대상이 다른 프로세스
        - 메시지를 전달하려는 프로세스가 통신하려는 프로세스의 이름을 명시적으로 표시
        - 커뮤니케이션 링크의 특징
            - 자동적으로 생성
            - 하나의 링크는 정확히 한 쌍의 프로세스에게 할당 ⇒ 각 쌍의 프로세스에게는 오직 하나의 링크만이 존재
            - 대부분의 경우 양방향성
    - **간접 통신(Indirect Communication)**
        - 메시지의 전송 대상이 메일박스라는 일종의 저장공간
        *메일박스 : 고유의 ID존재, 메일박스를 공유하는 프로세스들만 서로 통신 가능
        - 메시지를 전달하려는 프로세스가 mailbox(또는 port)를 통해 메시지를 간접 전달하는 방법
        - 새로운 메일박스를 생성하는 연산, 메일박스를 통한 메시지의 send()/receive() 연산, 메일박스를 삭제하는 연산 등이 사용된다.
        - 커뮤니케이션 링크의 특징
            - 프로세스 간에 메일박스를 공유하는 경우에만 생성된다.
            - 하나의 링크가 여러 프로세스들에게 할당될 수 있다. ⇒ 각 프로세스의 쌍은 여러 링크를 공유할 수 있다.
            - 단방향성 혹은 양방향성일 수 있다.
        - 발생 가능한 이슈 : 3개의 프로세스가 메일박스 A를 공유하는 경우 한 개의 프로세스가 보낸 메시지를 두 개의 프로세스 중 어떤 프로세스가 받게 되는가?
            - 해결 방법
                - 2개의 프로세스에게만 링크를 할당
                - 링크에 대한 receive() 연산을 매 시점 하나의 프로세스만 수행할 수 있도록 제한
                - 시스템이 메시지 수신자르 임의로 결정하고 송신자에게 수신 결과 통신

### 공유메모리 방식(shared memory)

- 서로 다른 프로세스들이 주소 공간의 일부를 공유하게 하는 메커니즘
- 처음에 커널에게 메모리를 공유하겠다는 시스템 콜을 해야한다.
- 공유메모리 영역은 각자의 주소 공간에 공통적으로 포함되므로 여러 프로세스가 읽고 쓰는 것이 가능
- 데이터의 일관성에 대한 이슈 발생 가능
- **thread(쓰레드)** : thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 프로세스 간의 협력으로 볼 수 있다.

---

<details>
    <summary><h3>스터디 질문 모음</h3></summary>
<div markdown="1">       

<h3>Q1. 프로세스 생성 과정에 대해 설명해주세요.</h3>

프로세스는 복제를 통해 생성된다. 먼저 부모 프로세스가 fork()라는 시스템 콜을 발생시키면 CPU의 제어권이 커널로 넘어가고 커널이 부모 프로세스의 주소 공간, 프로세스 카운터, 프로세스 제어 블록, 커널 스택 등 모든 문맥을 복사한 자식 프로세스를 생성한다.. 이후 자식 프로세스가 exec()이라는 시스템 콜을 통해 완전히 새로운 프로그램을 덮어쓰게 되고 해당 프로그램의 명령어를 수행하게 되면서 새로운 프로세스가 된다.

<h3>Q2. IPC 메커니즘은 어떤 경우에 사용되는 것이 좋은지 설명해주세요.</h3>

IPC 메커니즘은 서로 다른 프로세스들 간의 통신과 동기화를 이루고자 할 때 사용할 수 있는 메커니즘이다. 프로세스들 간의 협력을 통해 효율성을 제고하고자 할 경우 사용될 수 있다.

<h3>Q3. IPC 메커니즘 중 간접적으로 메세지를 전달하는 방식은 어떠한 메세징 기법인지 설명해주세요.</h3>

IPC 메커니즘에는 메시지 전달 방식과 공유메모리 방식 두가지가 있다. 그 중, 간접적으로 메시지를 전달하는 방식은 메시지 전달 방식 중 간접 통신에 해당한다. 이 경우 프로세스들이 통신을 할 때, 서로 공유하고 있는 메일박스나 포트를 통해 메시지를 주고 받으며 통신한다.

<h3>Q4. 프로세스와 관련된 시스템 콜 명령어 중 두 개를 골라 설명해주세요.</h3>

fork()와 exec()이라는 시스템 콜이 있다. fork()는 부모 프로세스가 자식 프로세스를 생성하고자 할 때 커널에게 보내는 시스템 콜로, 부모 프로세스와 완전히 동일한 자식 프로세스가 복제되어 생성된다. 이후 자식 프로세스가 exec() 시스템 콜을 통해 새로운 프로그램을 덮어쓰게 되고 이를 통해 부모 프로세스와는 완전히 다른 프로세스가 다.

</div>
</details>
