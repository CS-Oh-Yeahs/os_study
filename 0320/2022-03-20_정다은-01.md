# 운영체제 스터디 OS오예스 (2022-03-20 SUN 📚)
## 5장 프로세스 관리 Process Management
### 📂 프로세스 생성
#### 부모 프로세스가 자식 프로세스를 생성 (복제)
- 부모 프로세스는 운영체제에게 자식 프로세스를 만들어달라고 **시스템콜을 통해 요청**
- 트리(계층 구조) 형성
- 자식은 부모의 주소 공간(Address Space)를 그대로 복사한 후 해당 공간에 새로운 프로그램을 올림

#### 프로세스 관련 시스템콜
- **fork()**
  - create a child (copy)
  - 부모 프로세스를 복제하여 새로운 프로세스 생성
  - 부모의 PC를 포함한 문맥을 그대로 복사하므로 자식은 fork() 시스템콜 시점 이후부터 실행
  - fork 함수의 return value에 따라 부모/자식 구분 가능
    - 부모는 양수 값 (생성된 자식 프로세스의 PID)
    - 자식은 0

- **exec()**
  - overlay new image, can execute a different program 
  - 새로운 프로그램을 메모리에 덮어 씌운 후 새로운 프로그램의 첫 부분부터 다시 실행 시작
  - 본래 프로그램으로 되돌아 올 수 없으며 실행한 새로운 프로그램이 끝나면 종료<br/>
  *(즉, 원래 프로그램에서 exec() 시스템콜 이후에 있는 instructions는 영원히 실행 ❌)*
  - 반드시 자식을 만든 후에 exec 해야하는 것은 아니며 부모도 바로 exec 가능

> 📌 부모-자식 프로세스 사이에서의 **Copy-On-Write(COW)**
>- 사실상 부모 프로세스와 자식 프로세스는 독립된 프로세스이므로 자원을 공유하지 않는 것이 원칙
>- 단, 동일한 자원은 공유하는 것이 효율적이므로 write 발생 전까지는 *(내용의 변화가 나타나기 전까지는)* 부모의 주소 공간을 그대로 공유하고 있다가 write가 발생했을 때 부모의 주소 공간의 일부를 copy 하겠다는 것이 COW 개념!

- **wait()**
  - sleep until child is done
  - 자식 프로세스가 종료될 때까지 기다리는 시스템콜
  - 프로세스 A가 wait() 호출하면 커널은 child가 종료될 때까지 프로세스 A를 sleep 시킴 (block 상태) <br/>
  -> child가 종료되면 커널은 프로세스 A를 깨움 (ready)<br/>
  *ex) prompt(부모)에서 특정 프로그램(자식) 이름 입력하여 실행하면 prompt는 해당 프로그램 종료 시까지 다른 입력을 받지 않고 기다림*
  - 부모와 자식 간의 동기화가 가능하게 함

- **exit()**
  - frees all the resources, notify parent 
  - 자발적 종료: instructions 모두 수행 후 exit() 시스템 콜 불러 종료됨을 알림
    - 개발자가 명시적으로 호출하지 않아도 프로그램 종료 지점에 컴파일러가 자동으로 exit() 삽입
  - 비자발적 종료: 외부에서 강제로 종료시킴
    - 사람이 키보드로 kill, break 등을 친 경우
    - 부모 프로세스가 자식 프로세스의 수행을 종료시킨 경우 (abort)<br/>
      i) 자식이 할당 자원의 한계치를 넘어서는 많은 양의 자원 요구<br/>
      ii) 자식에게 할당된 태스크가 더 이상 필요하지 않음<br/>
      iii) 부모가 종료(exit)하는 경우 단계적 종료

> *프로세스의 세계에서는 자식 프로세스 먼저 종료 후 부모 프로세스를 종료하는 것이 원칙!*

### 📂 프로세스 간의 협력
> 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 주거나 받지 않으며 독자적인 주소 공간을 갖는 '독립적 프로세스'이나, 경우에 따라 '협력 프로세스'가 나타나기도 함

#### IPC; Interprocess Communication
- 프로세스 간의 통신과 동기화(공유 데이터의 불일치 문제 방지)를 이루기 위한 협력 매커니즘
- 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신
- **Message Passing**
  - 커널을 통해 메시지를 전달하는 방법
  - 링크를 생성한 후 send(), receive() 이용해서 메시지를 주고 받음 
    - **direct communication**: 통신하려는 프로세스의 이름을 명시적으로 표시
    - **indirect communication**: mailbox 또는 port 통해 간접적으로 전달
- **Shared Memory**
  - 주소 공간을 공유하는 방법
  - 서로 다른 프로세스 간 일부 주소 공간을 공유

## ❓ 문제
#### 프로세스 생성 과정에 대해 설명해주세요.
운영체제가 부팅되면 운영체제는 최조의 init 프로세스를 생성하고, 그 후에 생성되는 모든 사용자 프로세스는 fork 라는 시스템콜을 통해 부모 프로세스를 복제하여 자식 프로세스를 생성하는 방식으로 만들어집니다. 생성된 자식 프로세스는 exec 시스템콜을 통해 새로운 프로그램을 메모리에 덮어 씌운 후 해당 프로그램을 실행합니다.

#### IPC 메커니즘은 어떤 경우에 사용되는 것이 좋은지 설명해주세요.
IPC란 Interprocess Communication으로, 프로세스란 기본적으로 독자적인 주소 공간을 갖고 다른 프로세스의 영향을 주거나 받지 않는 것이 원칙이지만, 경우에 따라 프로세스 간의 통신과 동기화가 필요할 때 IPC를 활용하게 됩니다.

#### IPC 메커니즘 중 간접적으로 메세지를 전달하는 방식은 어떠한 메세징 기법인지 대답해주세요.
IPC의 기법 중 Message Passing 기법에는 direct/indrect 방식이 있는데, 이 중 간접적으로 메시지를 전달하는 방식인 indirect 방식은 통신하려는 프로세스의 이름을 명시적으로 표시하지 않고, mailbox나 port를 통해 간접적으로 전달합니다. 해당 mailbox나 port를 공유하는 프로세스 간의 통신이 가능합니다.

#### 프로세스와 관련된 시스템 콜 명령어 중 두 개를 골라 설명해주세요.
fork는 부모 프로세스를 복제하여 자식 프로세스를 생성하는 시스템콜, exec는 새로운 프로그램을 메모리에 덮어 씌워 실행하는 시스템콜, wait은 자식 프로세스의 작업이 끝날 때까지 부모 프로세스를 sleep 시켜 기다리게 하는 시스템콜, exit은 자원을 해제하고 부모에게 알리는 종료 시스템콜 입니다. 
