- CPU Burst : CPU만 사용하는 단계
- I/O Burst : I/O만 하는 단계
- 프로그램이 실행된다는 것은 CPU Burst와 I/O Burst를 반복하며 일어난다는 것이다.
- 프로그램마다 각 단계들의 비중은 차이가 있을 수 있다.
- I/O bound job(process) : CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job
- CPU bound job(process) : 계산 위주의 job
- 프로그램들은 각각의 특성에 따라 I/O burst가 길 수도 있고 CPU burst가 길 수도 있기 때문에 CPU Scheduling이 필요하다. 이를 통해 CPU를 효율적으로 사용할 수 있기 때문이다.
- 특히 CPU를 짧게 사용하는 I/O bound job들에게 적절한 response를 제공할 수 있게 CPU scheduling을 할 필요가 있다.

### CPU Scheduler

- 레디 상태의 프로세스 중 어떤 프로세스에게 CPU를 줄 지 선택하는 것
- 운영체제 안에 있는 코드 중 하나이다.
- 프로세스에 다음과 같은 상태 변화가 있는 경우 CPU 스케줄링이 필요하다.
    - Running → Blocked : CPU를 프로세스가 잡고 있다가 해당 프로세스가 I/O처럼 오래 걸리는 작업을 하게 되는 경우
    - Running → Ready : 할당 시간 만료로 인한 Timer Interrupt가 발생한 경우
    - Blocked → Ready : I/O 완료 후 인터럽트가 일어났고 I/O가 완료된 프로세스의 우선순위가 높은 경우
    - Terminate : 어떤 프로세스가 종료되었을 경우
    
    ⇒ 1, 4번은 **nonpreemptive(비선점형)** 즉, CPU를 강제로 빼앗지 않고 자진 반납하는 경우이고 그 외에는 **preemptive(선점형-현대의 CPU스케줄링 방법)** 즉, 강제로 빼앗아서(timer사용) 새로운 프로세스에게 CPU를 넘기는 경우
    

### Dispatcher

- 운영체제 안에 있는 코드 중 하나로 CPU의 제어권을 CPU Scheduler에 의해 선택된 프로세스에게 넘기는 코드이다.

### CPU Scheduling Criteria(Performance Measure, 성능 척도)

- 시스템 입장에서의 성능 척도
    - CPU utilization(이용률) : 최대한 CPU를 100% 사용하게 해라
        - 전체 시간중에서 CPU가 놀지 않고 일한 시간
        - 중국집 사장의 입장에서, 고용한 셰프가 일한 총 시간
    - Throughput(처리량)
        - 주어진 시간동안 몇 개의 작업을 완료했는지
        - 중국집 사장의 입장에서, 고용한 셰프가 총 몇 명의 손님을 받았는지
- 프로세스 입장에서의 성능 척도 : 프로세스 입장에서는 가능하면 CPU를 빨리 쓸 수록 좋다.
    - Turnaround time(소요 시간, 반환 시간)
        - CPU를 쓰러 들어와서 다 쓰고 나갈때까지 걸린 시간
        - 중국집에서 손님이 가게에 들어와서 요리를 모두 다 먹고 중국집을 나갈 때까지 걸린 총 시간
    - Waiting time(대기 시간)
        - CPU를 쓰고자 할 때 ready queue에서 기다리는 시간
        - 응답 시간과는
        - 손님이 중국집에서 밥을 먹는 시간을 제외하고 기다린 시간을 총 합한 것
    - Response time(응답 시간)
        - ready queue에 들어와서 처음으로 CPU를 얻기까지 걸린 시간
        - Time sharing 환경에서는 응답 시간의 개념이 사용자 입장에서 중요하다.
        - 중국집에서 첫번째 음식이 나올 때까지 손님이 기다린 시간

## CPU Scheduling Algorithms
일반적인 조건에서의 CPU 스케쥴링

### FCFS(First-Come First-Served)

- 먼저 온 프로세스를 가장 먼저 처리하는 방법
- 은행에서 손님을 처리하는 프로세스와 동일하다.
- 비선점형 스케줄링 기법
- CPU를 오래 쓰는 프로세스가 먼저 CPU를 잡아버리면 비교적 짧은 시간이 필요한 프로세스가 오랜 시간동안 기다리게 되므로 비교적 효율적이지 않은 방법이다.
- 작업에 소요되는 시간이 긴 프로세스가 먼저 도착할 때와 짧은 프로세스가 먼저 도착했을 때, waiting time이 확연히 달라지게 된다.
- Convoy Effect : 긴 시간이 소요되는 프로세스가 먼저 도착했을 때 짧은 시간이 소요되는 프로세스가 기다리게 되는 현상

### SJF(Shortest-Job-First)

- CPU burst가 가장 짧은 프로세스에게 CPU를 먼저 할당하는 방법
- average waiting time이 가장 짧은 기법이다. ⇒ preemptive 버전
- Nonpreemptive 버전
    - CPU할당 당시, CPU를 가장 짧게 사용하는 프로세스에게 CPU를 할당하고 해당 프로세스가 CPU를 사용하고 있을 경우 그 이후에 CPU 사용 시간이 더 짧은 프로세스가 대기 queue에 추가되어도 현재 CPU를 사용중인 프로세스로부터 CPU를 빼앗지 않는 방법
- Preemptive 버전
    - CPU를 주었다 하더라도 더 짧은 프로세스가 도착하면 해당 프로세스에 CPU를 넘겨주는 방법
    - shortest remaining time first(SRTF) 이라고도 부른다.
- 문제점
    - Starvation(기아 현상)
        - CPU 사용 시간이 상대적으로 긴 프로세스의 경우 무한정 대기하게 될 수 있다.
    - 프로세스들의 CPU 사용시간을 미리 알 수 없다.
        - exponential averaging : 과거의 CPU 사용시간들을 통해 프로세스의 CPU 사용시간을 예측하는 방법

### Priority Scheduling

- 우선순위가 가장 높은 프로세스에게 CPU를 할당하는 방법
- 각 프로세스마다 우선순위를 나타내는 정수값의 숫자가 할당되어 있다. 우선순위가 가장 높은 프로세스는 가장 작은 숫자를 갖는다.
- SJF 스케쥴링도 우선순위 스케쥴링의 일종이다. ⇒ CPU 사용 시간이 가장 적은 프로세스가 우선순위가 높은 경우
- Nonpreemptive 버전
    - 우선순위가 더 높은 프로세스가 도착하더라도 기존에 CPU를 사용하고 있는 운영체제에게서 CPU를 빼앗지 않는다.
- Preemptive 버전
    - 우선순위가 더 높은 프로세스가 도착하면 기존에 CPU를 사용하고 있는 운영체제에게서 CPU를 빼앗는다.
- 문제점
    - Starvation(기아 현상) : 우선순위가 높은 프로세스에게 CPU가 계속해서 할당되다 보니 우선순위가 높지 않은 프로세스는 계속해서 CPU 할당을 받지 못하는 현상
- 해결 방법
    - Aging(노화) : 우선순위가 낮은 프로세스라고 하더라도 오래 기다리게 되면 우선순위를 높여주는 방법

### Round Robin(RR)

- 현대 컴퓨터에서 사용하는 방법
- preemptive 스케쥴링 기법
- CPU를 프로세스에 할당할 때, 프로세스별로 갖는 할당 시간대로 할당하게 된다.
    
    즉, 할당 시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에 가서 줄을 선다.
    
- 장점
    - 응답 시간이 빨라진다. ⇒ CPU를 최초로 얻기까지 걸리는 시간이 짧아진다.
        
        어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
        
    - CPU burst시간에 대한 예측이 필요 없어진다.
- 특징
    - 프로세스가 CPU를 대기하는 시간은 그 프로세스가 CPU를 필요로 하는 시간과 비례한다.
- 의의
    - 프로세스에게 할당되는 CPU 할당시간이 너무 커지게 되면 FCFS 기법과 같아진다.
    - 프로세스에게 할당되는 CPU 할당시간이 너무 작아지게 되면 컨텍스트 스위치가 너무 자주 일어나 오버헤드가 발생하게 된다.
    - 따라서 적당한 규모의 할당 시간을 주는 것이 중요하다. (보통, 10-100 milliseconds)
