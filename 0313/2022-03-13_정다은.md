# 운영체제 스터디 OS오예스 (2022-03-13 SUN 📚)  
## 컴퓨터 시스템의 동작 원리 System Structure 

### 📂 컴퓨터 시스템의 구조
<img src="https://user-images.githubusercontent.com/59408502/158014874-959412f6-b78b-42c4-bee0-18598dc84f04.png" width="75%" height="75%" />

- 컴퓨터 내부장치 : **CPU, Memory**
- 컴퓨터 외부장치 : **I/O device** (입출력 장치; 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등)
<br/> *cf) 하드디스크는 보조기억장치이자 I/O 디스크로 볼 수도 있음. 하드디스크에 있는 데이터를 메모리로 읽어들이기도 하고, 처리 결과를 디스크 파일 시스템에 저장하기도 하기 때문.*

> **입력(Input)**: I/O device에서 받은 데이터가 컴퓨터로 들어오는 것 <br/>
> **출력(Output)**: 컴퓨터의 데이터 처리 결과 등을 외부 장치로 내보내는 것
<br/>

### 📂 CPU 연산과 I/O 연산
- 컴퓨터 내 수행되는 CPU 연산은 메인 **CPU 담당** vs 입출력 장치들의 I/O 연산은 **Device Controller가 담당**
- CPU의 작업 공간은 **Main Memory** vs Device Controller의 작업 공간은 **Local Buffer**

> 컴퓨터에서 연산을 한다는 것은 CPU가 무언가 일을 한다는 뜻으로 CPU는 매 시점 작업 공간인 메모리에서 명령(instruction)을 하나씩 읽어서 실행한다. CPU에 비해 I/O device는 매우 느리므로, CPU는 I/O device를 직접 접근하지 않으며 Device Controller에게 특정 데이터를 읽어올 것을 시킨다. **이에 I/O device를 전담하여 디스크 내부를 통제하는 것은 CPU가 아닌 Device Controller의 책임이다.** 그렇다면 키보드에서 어떤 입력이 들어왔다든지, 디스크에서 읽기 요청을 다 끝냈다든지 등의 여부를 CPU는 어떻게 알 수 있는가. **Device Controller가 '인터럽트'를 발생시켜 CPU에 보고하는 형태로 알 수 있다.**
<br/>

### 📂 인터럽트의 일반적 기능
- **하드웨어 인터럽트**: 일반적으로 일컫는 인터럽트, 하드웨어가 CPU에 정보를 교신하기 위해 걸 수 있음
- **소프트웨어 인터럽트**: 트랩(trap)이라고도 부름
  - **exception**: 프로그램이 오류를 범한 경우 ex) 0으로 나눈 경우
  - **system call**: 프로그램이 필요에 의해서 커널 함수를 호출하는 경우
  <br/> *cf) 시스템콜이란, 사용자 프로그램이 운영체제 서비스를 받기 위해 커널 함수를 호출하는 것!*

ex) I/O 요청은 소프트웨어 인터럽트 vs I/O 완료 알림은 하드웨어 인터럽트

> 인터럽트 관련 용어 <br/>
**인터럽트 벡터**: 인터럽트 종류마다 번호를 정해서 번호에 따른 인터럽트 처리 루틴 주소 가지고 있는 자료 구조 <br/>
**인터럽트 처리 루틴**: 해당 인터럽트를 처리하는 커널 함수로, 각각의 인터럽트 종류마다 처리해야하는 업무가 정의되어 있음 
<br/>

### 📂 인터럽트 핸들링
> *CPU는 매번 PC(Program Counter)가 가리키고 있는 지점의 명령을 하나씩 수행 → 다음 명령 수행 직전에 인터럽트 라인이 세팅되었는지 체크 → 프로그램 A 실행 중 인터럽트 발생 → A의 현재 상태를 PCB에 저장 → CPU의 제어권이 운영체제의 인터럽트 처리루틴으로 넘어감 → 인터럽트 처리 끝 → PCB로부터 저장된 상태를 CPU 상에 복원 → 실행 재개*

**"운영체제는 인터럽트에 의해 구동된다"**
- 시스템 부팅 후 정상 상태에 머무르게 되면 **CPU는 항상 사용자 프로그램에 의해 사용**
- **운영체제는 단지 인터럽트가 발생했을 때만** 잠깐 CPU의 제어권 획득
<br/>

### 📂 입출력 구조
- **동기식(synchronous) 입출력**
: I/O 요청 후 I/O 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감 <br/>
  - CPU가 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원 낭비하는 문제
  - 매시점 하나의 I/O만 가능한 문제 <br/>
  *-> 입출력이 수행되는 동안 다른 프로그램에게 CPU를 양도하여 해결 가능 <br/>
  but 동시에 다수의 입출력 연산이 일어날 수 경우 동기성(synchronization)을 보장하기 위한 장치가 반드시 필요 <br/>
  ex) 장치마다 큐를 두어 요청된 순서대로 처리할 수 있도록 함*
  
- **비동기식(asynchronous) 입출력**
: I/O가 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
: I/O 작업과 무관하게 수행할 수 있는 작업부터 처리
<br/>

### 📂 DMA (Direct Memory Access) Controller
- **CPU 외 직접 메모리를 접근할 수 있는 컨트롤러**
- 원칙적으로는 메인메모리는 cpu만 접근할 수 있으나, **I/O 장치가 너무 자주 인터럽트를 걸면 CPU가 방해를 받게 되는 문제를 해결**하기 위함
- DMA는 **완료된 I/O 작업에 대해 로컬 버퍼의 데이터를 메모리에 데이터를 메모리에 저장**하고 해당 작업 완료 시 CPU에게 인터럽트를 발생
- DMA는 바이트 단위가 아니라 블록 단위라는 큰 단위로 정보를 메모리로 읽어온 후 CPU에 인터럽트 발생
- CPU, DMA 동시에 특정 메모리 영역을 접근하면 문제가 발생할 수 있으므로 이 부분에 대해서는 **memory controller**가 제어
<br/>

### 📂 저장장치의 구조
- **주기억장치**: 휘발성(volatile) RAM 주로 사용
- **보조기억장치**: 비휘발성(nonvolatile) 마그네틱 디스크 주로 사용
  - **파일 시스템용**: 비휘발성 용도
  - **스왑 영역**: 메모리의 연장 공간. 다수 프로그램 실행 시 메모리 공간이 부족한 경우 운영체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓음 (스왑 아웃). 프로그램 종료 시 삭제되므로 비휘발성 용도와 구분.
<br/>

### 📂 저장장치의 계층 구조
<img src="https://user-images.githubusercontent.com/59408502/158013872-5a8f9dbc-619e-48fb-b06a-4c84d0d320cc.png" width="50%" height="50%"/>

- 위로 갈수록 주로 속도 빠름 / 단위 공간 당 가격이 비쌈 / 용량이 적음
- Primary: CPU가 직접 접근해서 처리 ⭕ executable ⭕ bite 단위 접근이 가능
- Secondary: CPU가 직접 접근 ❌ executable ❌ 하드디스크 같은 경우 바이트 아니고 섹터 단위 접근 등

> cf) **caching**
> : **copying information into faster storage system** <br/>
> : 빠른 매체로 정보를 읽어들여서 쓰는 것으로 **주로 재사용 목적** <br/>
> : 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상. 두 저장장치 사이의 속도를 완충. 
<br/>

### 📂 하드웨어의 보안
- 커널모드 vs 사용자모드 구분
- **mode bit**
: cpu에서 현재 실행되는 것이 운영체제인지 사용자 프로그램인지 구분
  - mode bit이 0일 경우: 커널 모드. 운영체제가 수행 중. 무슨 명령이든 다 수행 가능. 입출력 명령, 메모리 접근 등.
  - mode bit이 1일 경우: 사용자 모드. 사용자 프로그램이 실행 중. 제한된 instruction만 실행 가능. 특권 명령 실행 불가능.
<br/>

### 📂 메모리 보안
> 기준 레지스터(base register): 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적 으로 접근할 수 있는 메모리 상의 가장 작은 주소 보관
> 한계 레지스터(limit register): 기준 레지스터 값부터 해당 프로그램이 접근할 수 있는 메모리의 범위 보관

- 기준 레지스터와 한계 레지스터의 값으로 **접근 위치의 합법성 체크**
- **불법적인 메모리 접근은 소프트웨어 인터럽트 발생** → 제어권 운영체제로 이양 → 운영체제는 예외상황을 발생시킨 프로그램 강제 종료
- 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 메모리에 한정적으로 적용 가능
- 메모리 접근 명령 자체는 특권명령 ❌ 기준 레지스터 한계 레지스터 값 세팅 연산은 특권명령 ⭕
<br/>

### 📂 CPU 보호
- **특정 프로그램이 CPU를 독점하는 것을 방지**
- 운영체제가 사용자 프로그램에 CPU를 넘겨줄 때 **timer**에 일정 시간 세팅한 후 넘겨줌
- 타이머 값을 세팅하는 명령은 로드 타이머(load timer)로 특권 명령의 하나
- 매 클럭 틱마다 1씩 감소하고 타이머가 0이 되는 순간 인터럽트 발생하며 CPU 제어권을 뺏어올 수 있음
- 시분할 시스템에서 현재 시간을 계산하기 위해서도 사용됨
<br/>

## 4장 프로그램의 구조와 실행 Program Execution
### 📂 프로그램의 구조와 인터럽트
- 컴퓨터 프로그램의 내부 구조는 **함수들로 구성**
- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 **프로그램의 주소 영역이 메모리에 올라가 있어야 함**
- 프로그램의 주소 영역은 **코드(code), 데이터(data), 스택(stack)** 영역으로 구분

> *하나의 함수가 수행 중 → 다른 함수 호출 → 호출된 함수의 수행이 종료 → 다시 원래 호출했던 함수의 위치로 돌아가 프로그램을 계속 실행*

- 원래 함수가 수행되던 위치로 돌아갈 때 **스택에 저장되어 있는 복귀 주소** 사용
- 인터럽트의 동작 원리도 유사하나 **인터럽트 때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 PCB(Process Control Block)** 에 저장
<br/>

### 📂 프로그램의 실행
**프로그램이 실행되고 있다** 의 의미
- 디스크에 존재하던 실행파일이 **메모리에 적재**된다
- 프로그램이 **CPU를 할당**받고 명령을 수행하고 있는 상태이다

### 📂 사용자 프로그램이 사용하는 함수
- 사용자 정의 함수
- 라이브러리 함수
- 커널 함수

### 📂 프로세스의 두 가지 실행 상태 
- 사용자모드 vs 커널모드 실행 상태로 구분
  - 프로그램이 **사용자 정의함수나 라이브러리 함수** 호출 시에는 **사용자모드**에서 실행 지속
  - **시스템 콜** 호출 시에는 **커널모드**로 진입

### ❓ 문제
#### Q1. 사용자 프로그램이 I/O를 요청했을 때 일어나는 일을 설명해보시오.
I/O 작업은 보안 상 문제가 될 수 있는 작업이므로 운영체제만 수행 가능합니다. 따라서, 사용자 프로그램이 I/O 작업을 하고자 할 때에는 시스템콜을 통해 CPU에게 소프트웨어 인터럽트를 발생시키게 됩니다. 인터럽트를 발견한 CPU는 제어권을 운영체제에게 넘겨주며, 운영체제는 디바이스 컨트롤러에게 I/O 작업을 수행할 것을 명령합니다. I/O 작업이 끝나면 이번에는 디바이스 컨트롤러가 CPU에게 I/O 작업이 완료되었음을 알리기 위해 하드웨어 인터럽트를 발생시키며, 인터럽트를 발견한 CPU는 해당 디바이스의 로컬 버퍼에 저장된 데이터를 메인 메모리로 전달해오고 운영체제는 이전에 I/O 작업을 요청한 프로그램을 다시 CPU를 할당받을 수 있는 상태로 전환시킵니다.

#### Q2. DMA 컨트롤러의 기능을 설명해주세요.
DMA 컨트롤러는 CPU 외에 직접 메모리에 접근할 수 있는 컨트롤러입니다. 원칙적으로 메인 메모리에는 CPU만 접근이 가능하지만, 빈번한 I/O 작업이 인터럽트를 걸 경우 CPU의 작업이 방해받는 문제가 발생합니다. 따라서, 해당 문제를 해결하고 CPU의 효율성을 높이기 위해 DMA 컨트롤러는 I/O 작업이 완료되면 해당 I/O 디바이스의 로컬 버퍼에 저장된 값을 메인 메모리로 옮겨와 주는 역할을 대행하고 여러 I/O 작업 완료 인터럽트를 모아 CPU에게 한 번만 인터럽트를 발생시킵니다.

#### Q3. 시스템콜에 대해 설명해보세요.
시스템콜이란 입출력, 메모리 접근과 같이 보안 상의 문제로 인해 운영체제만 수행할 수 있는 서비스를 이용하기 위해 사용자 프로그램이 커널 공간에 있는 함수를 호출하는 인터페이스를 말합니다.
