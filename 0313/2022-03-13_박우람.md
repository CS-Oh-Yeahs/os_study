# os_study 1주차 - 02

## System Structure & Program Execution 1, 2


### 컴퓨터 구조
![image](https://user-images.githubusercontent.com/56028408/157796926-1bb83571-56ea-404a-b551-048cb898fdaf.png)

- 전문가적 입장에서 컴퓨터를 말할 때, 보통 CPU와 Memory를 말한다.
- 컴퓨터는 CPU, Memory, I/O Device, Disk, 네트워크 장비들로 구성되어있다


### 컴퓨터 시스템 구조

#### CPU
1. CPU는 매 클럭사이클 마다 메모리에서 instruction을 하나씩 읽어서 실행한다.
2. instruction 수행이 종료되면 Interrupt Line을 체크하고 인터럽트 신호가 확인되면 수행한다.

#### Interrupt Line
1. 인터럽트 라인에 인터럽트가 쌓이면 CPU는 실행중인 프로그램을 저장해두고 인터럽트 명령을 수행한다.


#### Mode bit
1. 사용자가 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치
2. 하드웨어적으로 두 가지 모드의 Operation 지원
    a 1 사용자 모드: 사용자 프로그램 수행
    b 0 커널 모드: OS 코드 수행
3. 보안을 해칠 수 있는 중요한 명령어는 커널 모드에서만 수행 가능한 **특권명령**으로 규정
4. Interrupt나 Exception 발생시 하드웨어가 mode bit를 0으로 바꿈
5. 사용자 프로그램에게 CPU를 넘기기 전에 mode bit를 1로 셋팅

#### Registers
1. 메모리보다 더 빠른 정보를 저장할 수 있는 공간

#### Timer
1. 특정 프로그램이 CPU를 독점하는 것을 방지하기 위한 장치
2. 운영체제가 사용자 프로그램에게 CPU를 넘겨줄 때 Timer에 값을 지정해서 넘겨준다. 
3. 타이머 값이 0이 되면 타이머가 CPU에게 인터럽트 신호를 발신한다.
4. 타이머는 time sharing을 구현하기 위해 널리 이용됨
5. 타이머는 현재 시간을 계산하기 위해서도 사용됨

#### Memory
1. 램은 CPU가 처리할 데이터나 명령어가 임시로 저장되는 곳으로 작업 공간 역할을 한다. 컴퓨터 작업을 할 때 하드디스크에 있는 데이터는 먼저 메모리로 이동된 다음 CPU로 전송된다. 프로그램의 실행도 이와 마찬가지로, CPU가 메모리에 저장되어 있는 용량만큼 프로그램을 작동시킨다.
- 출처 https://inter87.tistory.com/7

#### I/O Device
1. 각각의 I/O Device는 각 디바이스를 전담하는 Controller를 가지고 있다. 
2. Controller는 각 I/O 디바이스의 내부를 통제하는 작업을 담당한다. CPU에게 인터럽트를 발생시키는 것도 Controller가 담당한다. 
3. I/O Device는 CPU에 비해 처리속도가 상당히 느리다.
4. I/O Device는 모두 각각의 Local Buffer를 가지고 있다.  

#### I/O Device Controller 
1. 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
2. 제어 정보를 위해 control register, status register를 가짐
3. local buffer를 가짐 (일종의 data register)
4. I/O는 실제 device와 local buffer 사이에서 일어남
5. Device Controller는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림

####  DMA Controller
1. CPU와 동일하게 직접 메모리에 접근 가능한 컨트롤러
2. I/O device의 localBuffer의 작업이 끝나면 DMA Controller가 데이터를 메모리에 복사한다. I/O Device의 인터럽트 작업을 수행한 후 합쳐서 CPU에게 인터럽트를 보낸다.

### 인터럽트 (Interrupt)
1. 인터럽트
    a. 인터럽트 당한 시점의 레스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다
2. 넓은 의미의 인터럽트
    a. interrupt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트
    b. trap (소프트웨어 인터럽트) 
        - Exception: 프로그램이 오류를 범한 경우
        - System call: 프로그램이 커널 함수를 호출하는 경우
3. 인터럽트 관련 용어
    a. 인터럽트 백터
        - 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    b. 인터럽트 처리 루틴
        - 해당 인터럽트를 처리하는 커널 함수


### 입출력 (I/O)의 수행
1. 모든 입출력 명령은 특권 명령이다.
2. 사용자 프로그램이 I/O를 하는 방식
    a. 시스템콜(system call)
        i. 사용자 프로그램이 운영체제의 서비스를 받기위해 호출하는 것
3. trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
4. 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
5. 올바른 I/O 요청인지 확인 후 I/O 수행
6. I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

#### 1. 동기식 입출력
    동기식 입출력은 어떤 프로그램이 입출력 요청을 했을 때
    입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식을 말한다.

##### 1.1 동기식 입출력의 실행 방식
    동기식 입출력은 프로그램이 디스크에서 어떤 정보를 읽어오라는 요청을 했을 때 디스크 입출력이 진행되는 동안 그 프로그램의 다음 명령을 수행하지 않고 기다린다. 그러다가 입출력이 완료되어 인터럽트를 통해 완료 사실이 전달된 후에야 CPU의 제어권이 해당 프로그램에게 넘어간다. 

    따라서 동기식 입출력에서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비하게 된다.
    한편 CPU의 명령 수행 속도는 빠르지만 입출력 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 느리다. 
    
    그럼에도 불구하고 입출력이 완료될 때까지 대기했다가 사용자 프로그램에게 CPU의 제어권을 넘기는 방식은 자원 낭비를 초래한다. 
    
    따라서 일반적으로 프로그램이 입출력을 수행 중인 경우 CPU를 입출력을 실행한 프로그램에게서 빼앗아 다른 프로그램에게 할당하고 입출력을 수행중인 프로그램은 봉쇄상태로 변경한다.

#### 2. 비동기식 입출력
    비동기식 입출력은 프로그램이 디스크 정보를 요청하더라도 프로그램을 봉쇄상태로 이동하지 않고 다음 작업을 수행한다. 

##### 2.1 비동기식 입출력의 실행 방식
비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라
CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식을 말한다. 

어떤 프로그램이 데이터를 디스크에서 읽어오라는 요청을 했을 때 보통은 읽어온 결과를 이용해서 다음 연산을 수행하지만
경우에 따라서는 그 데이터와 관련없이 수행할 수 있는 일이 있을 것이다.
비동기식 입출력에서는 그러한 작업을 먼저 수행하고, 읽어오는 데이터가 반드시 이어야 수행할 수 있는 일들은
입출력이 완료된 후에 수행하게 된다. 

또한 디스크에서 읽어오는 요청이 아니라 디스크에 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령을
수행할 수 있으므로 비동기식 입출력이 사용될 수 있다.


### 프로그램의 구조와 실행

#### 1. 프로그램의 구조와 인터럽트
프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.
이떄 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다. 

##### 1.1 코드영역
- 코드영역은 작성한 프로그램의 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분

##### 1.2 데이터 영역
- 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분

##### 1.3 스택 영역
- 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간

#### 2. 컴퓨터 시스템의 작동 개요
    CPU는 빠른 속도로 처리하는 계산 능력은 가지고 있지만, 수행해야하는 작업을 스스로 결정하는 능력은 갖추고 있지 않다. 
    CPU는 매 시점 메모리의 특정 주소에 존재하는 명령어를 하나씩 읽어와서 그대로 실행한다. 
    이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다.
    CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 된다.

#### 3. 프로그램의 실행
    프로그램이 실행되고 있다는 것은 디스크에 존재하면 실행파일이 메모리에 적재된다는 의미와
    프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태라는 의미이다.

- 현재 수행 중인 프로그램을 프로세서(process)라고 부른다.
- 각 프로그램은 코드, 데이터, 스택영역과 같은 주소 공간을 별도로 가진다
- 프로그램마다 독자적으로 존재하는 주소공간을 가상메모리 또는 논리적 메모리라고 부른다.




----
 **[질문 리스트]**

 1. 사용자 프로그램이 I/O를 요청했을 때 일어나는 일을 설명해보시오
    - 사용자는 직접 입출력 장치에 접근할 수 없기 때문에 시스템 콜을 하여 운영체제에게 I/O 작업을 요청한다. 
    운영체제는 요청받은 I/O 명령을 사용자 프로그램 모드가 아닌 커널 모드에서 해당 요청에 맞는 처리코드를 수행하게 된다. 
    예를 들어 디스크에서 자료를 읽어오는 시스템 콜이라면, CPU가 디스크 컨트롤러에게 데이터를 읽어오라는 명령을 내린다.

 2. DMA 컨트롤러의 기능을 설명해주세요.
    - CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주어서
    CPU에 발생하는 인터럽트의 빈도를 줄여 CPU를 효율적으로 관리할 수 있게 도와주는 역할을 한다.
    - DMA를 사용하면 CPU가 로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 대행한다.
    - DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜 작업이 끝난 것을 알린다.
3. 시스템콜에 대해 설명해보세요
    - 시스템 콜이란 사용자 프로그램 특권명령을 수행하기 위해 운영체제에게 해당 작업을 요청하는 행위이다. 
    시스템 콜은 일종의 소프트웨어적인 인터럽스로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU의 제어권이 운영체제로 넘어가게 된다. 그러면 운영체제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행한다.