# 디스크 관리와 스케쥴링

## 디스크의 구조

### Logical Block

- 디스크 외부에서 보는 디스크의 단위 정보를 저장하는 공간들
- 주소를 가진 1차원 배열처럼 취급
- 정보를 전송하는 최소 단위

### Sector

- 디스크를 내부에서 관리하는 최소단위
- logical block이 물리적인 디스크에 매핑된 위치
- Sector 0은 디스크의 가장 바깥 쪽 실린더의 첫 트랙에 있는 첫 번째 섹터이다.
⇒ 어떤 파일 시스템에서든 부팅과 관련된 정보를 담고 있다.

---

## 디스크 관리

### Physical Formatting(low-level formatting)

- 디스크를 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누는 과정
- 각 섹터는 header + 실제 데이터(보통 512 bytes) + trailer로 구성된다.
- header와 trailer는 섹터 번호, ECC(Error-Correcting code) 등의 정보가 저장되며 이는 controller가 직접 접근하고 운영한다.
*ECC : 해시함수 식으로 디스크 내의 실제 데이터를 압축해놓은 정보. 디스크에서 데이터를 읽어올 때 header와 trailer내의 ECC와 실제 데이터를 비교하여 bad sector인지 아닌지를 판별한다. ECC의 규모에 따라 에러만 검출하거나 에러를 검출하고도 수정까지 할 수 있는 정보를 담게 된다.

### Partitioning

- 디스크를 하나 이상의 실린더 그룹으로 나누는 과정
예) C드라이브, D드라이브처럼
- OS는 이를 독립적인 디스크로 취급하게 된다.(logical disk)
- 파티션 된 공간은 파일 시스템 용도 혹은 swap area로 사용할 수 있다.

### Logical Formatting

- 파티션에 파일 시스템을 설치하는 것
- FAT, inode, free space 등의 구조를 포함한다.

### Booting

- CPU는 메모리에만 접근가능하고 하드디스크에는 접근하지 못한다.
- 메모리 중 전원이 나가더라도 내용이 유지되는 ROM이라는 메모리에 부팅을 위한 간단한 loader(small bootstrap loader)가 저장되어 있어 이를 실행하게 된다.
- sector 0번의 내용(boot block)을 메모리에 올리고 이를 실행하라고 small bootstrap loader가 지시한다.
    - sector 0번은 full bootstrap loader program이다.
- 이후 부트 블록은 파일 시스템에서 운영체제의 커널 위치를 찾아 메모리에 올려 실행하라고 지시한다.

---

## 디스크 스케쥴링

### 디스크를 접근하는 Access time의 구성

### Seek time

- 디스크 헤드가 안쪽 실린더 혹은 트랙으로 이동해야 작업을 처리할 수 있는데
    - 이 때 헤드를 해당 실린더로 움직이는 데에 걸리는 시간을 말한다.
    - 디스크를 읽고 쓰는데에 걸리는 시간 중 대부분을 차지
    
    ### Rotational latency
    
    - 원판이 회전해서 섹터의 위치가 디스크의 헤드가 있는 곳으로 위치하는 데까지 걸리는 시간
    즉, 헤드가 원하는 섹터에 도달하기까지 걸리는 회전지연시간
    
    ### Transfer time
    
    - 실제 데이터의 전송 시간

### Disk Bandwith

- 단위 시간 당 전송되는 바이트의 수

### Disk Scheduling

- seek time을 최소화하는 것이 목표이다.

---

## Disk Scheduling Algorithms

- 기본적으로 SCAN 알고리즘에 기반한 알고리즘들을 사용하고 있다.

### FCFS(First Come First Service)

- 먼저 도착한 실린더 순서대로 처리하는 방법
- 바깥쪽 실린더, 안쪽 실린더 이런 식으로 도착하게 될 경우 seek time이 많이 소요된다.

### SSTF(Shortest Seek Time First)

- 큐에 쌓여있는 요청 중, 현재 헤드 위치에서 제일 가까운 요청을 가장 먼저 처리하는 방법
- 만약 큐에서 가까운 요청들이 앞쪽에 계속 쌓이게 되면 큐에서 거리가 있는 요청은 계속해서 헤드에 접근하지 못하는 starvation 문제가 발생할 수 있다.

### SCAN

- 스케쥴링 기법 중 가장 획기적인 방법
- 엘리베이터 스케쥴링이라고도 부른다.
- 큐에 어떤 요청이 들어왔는지 상관하지 않고, 디스크 arm이 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다.
- 다른 한쪽 끝에 도달하면 역방향으로 다시 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동한다.
- 실린더의 위치에 따라 대기 시간이 다르다는 문제점이 있다.
왼쪽 끝에 있는 실린더는 헤드가 한바퀴를 왕복할 때까지 기다려야 하지만 가운데 실린더는 최악의 상황에서도 편도 한바퀴만 기다리면 된다.

### C-SCAN(Circular - SCAN)

- 헤드가 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다.
- 다른쪽 끝에 도착했으면 요청을 처리하지 않고 곧바로 출발점으로 다시 이동한다.
- SCAN보다 균일한 대기 시간을 제공한다.

### 그외 알고리즘

### N-SCAN

- SCAN의 변형 알고리즘
    - 일단 헤드가 한 방향으로 이동하기 시작하면 시작 시점에 미리 큐 중 해당 방향에 쌓여있던 요청들을 처리하고, 시작 이후에 쌓인 요청들은 다음 회전때 처리하는 방식
    
    ### LOOK and C-LOOK
    
    - SCAN이나 C-SCAN은 요청이 있든 없든 헤드가 디스크 끝에서 끝으로 이동하는 방식이다.
    - 이와 달리 LOOK과 C-LOOK은 헤드가 진행 중이다가 그 방향에 더이상 기다리는 요청이 없으면 헤드의 이동방향을 즉시 반대로 이동시키는 방식이다.

## 디스크 스케쥴링 알고리즘을 결정하는 법

- 현대에는 SCAN에 기반한 알고리즘을 사용한다.
- SCAN, C-SCAN 및 그 응용 알고리즘은 LOOK C-LOOK 등이 일반적으로 디스크 입출력이 많은 시스템에서 효율적인 것으로 알려져 있다.
- 파일의 할당 방법에 따라 디스크 요청이 영향을 받는다.
- 필요할 경우 다른 알고리즘으로 쉽게 교체할 수 있도록 OS와 별도의 모듈로 작성되는 것이 바람직하다.

---

## Swap-Space Management

### Disk를 사용하는 두 가지 이유

- 메모리의 volatile(휘발성)한 특성으로 인해 파일 시스템처럼 영속적으로 데이터를 유지해야하는 비휘발성의 디스크를 사용하게 된 것이다.
- 프로그램 실행을 위한 메모리 공간이 부족하기 때문이다. 메모리의 연장 공간으로 디스크를 swap area(space)의 용도로 사용한다.

### Swap space(swap area) - 하드디스크에서 이 영역을 관리하는 방법

- 프로세스가 시작되고 실행되는 시간 동안에만 내용들이 저장되는 영역. 프로세스 종료 시 저장된 내용들은 모두 사라지게 된다.
- 물리적 디스크에서는 디스크를 메모리의 연장 공간으로 사용한다.
- 파일 시스템 내부에 둘 수도 있지만 별도 파티션 공간으로 사용하는 것이 일반적이다.
    - 공간 효율성보다는 속도 효율성이 우선이다.
    - 일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조된다.
    - 따라서 block의 크기 및 저장 방식이 일반 파일시스템과 다르다.

---

## RAID(Redundant Array of Independent Disks)

- 여러 개의 디스크를 묶어서 사용하는 것
- 데이터를 중복 저장하기도, 분산 저장하기도 한다.

### 사용 목적

### 디스크 처리 속도 향상

- 여러 디스크에 block의 내용을 분산 저장하여 병렬적으로 해당 내용을 읽어오게 되면 속도가 훨씬 향상된다. 
⇒ 이를 Interleaving, Striping 이라고 한다.

### 신뢰성 향상

- 동일 정보를 여러 디스크에 중복 저장함으로써 하나의 디스크가 고장나면 다른 디스크에서 읽어올 수 있다.
⇒ 이를 Mirroring, Shadowing 이라고 한다.
- 단순한 중복 저장 방식이 아닌 일부 디스크에 parity를 저장하여 공간의 효율성을 높인다.
* parity : 공통의 내용 중 parity와 중복되는 내용들의 비교를 통해 내용의 오류 등을 확인할 수 있는 아주 작은 부분을 말한다.
