# Disk Management & Scheduling

### 📂 Disk Structure

- **Logical Block**
    - **디스크 외부**에서의 디스크 접근의 최소 단위
    - 1차원 배열처럼 취급
    - 정보를 전송하는 최소 단위
- **Sector**
    - **디스크 내부**에서 디스크를 관리하는 최소 단위
    - **logical block이 물리적인 디스크에 매핑된 위치**
    - 섹터 0번은 최외곽 실린더의 첫 번째 트랙에 있는 첫 번째 섹터 *→ 부팅과 관련된 정보 저장*

### 📂 Disk Management

- **Physical Formatting (Low-Level Formatting)**
    - **디스크 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누는 과정**
    - 각 섹터는 **header + 실제 data (보통 512 bytes, 디스크 외부에서 읽고 쓰라고 요청한 logical block) + trailer** 로 구성
    - header, trailer → 주소 매핑을 위한 섹터 번호, Error-Correcting Code *(저장한 데이터에 대한 일종의 축약된 fingerprint, hash 값)* 등의 부가적 정보 저장
- **Partitioning**
    - **섹터 영역들을 묶어주어 하나의 독립적인 디스크(logical disk)로 만들어주는 과정**
    - 디스크를 하나 이상의 실린더 그룹으로 나누는 과정
    - 파티셔닝이 끝나고 나면 각각의 파티션을 file system 또는 swap area로 활용할 수 있음
- **Logical Formatting**
    - file system을 만드는 것
    - FAT, inode, free space 등의 구조 포함
- **Booting**
    - 파일 시스템 안에 있는 운영체제가 메모리에 올라와서 부팅되는 과정
        - 메모리는 비어 있는 상태, CPU는 메모리만 접근 가능한 장치
        - 전원이 켜지면 CPU는 메모리 영역 중 전원이 나가더라도 내용이 유지되는 소량의 부분인 ROM의 주소를 가리키며 ROM은 small bootstrap loader 실행
        - 하드디스크 섹터 0번의 내용을 메모리에 올리고 실행
        - 섹터 0번에 위치한 full bootstrap loader program 실행
        - 파일시스템에서 운영체제 커널의 위치를 찾아 메모리에 올려서 실행하라고 함

### 📂 Disk Scheduling

![image](https://user-images.githubusercontent.com/59408502/163912144-e87de405-6dfc-428c-bfd7-d624e667dfe2.png)

- **Access Time** *(디스크를 접근하는 시간)* 의 구성
    - **Seek Time**
        - 디스크 헤드가 읽거나 쓰는 작업을 요청한 트랙/실린더로 이동하는데 걸리는 시간
        - 디스크 접근 시간 요소 중 가장 큰 부분 차지
    - **Rotational Latency**
        - 원판이 회전하여 헤드가 원하는 섹터에 도달하기까지 걸리는 회전 지연 시간
        - seek time 보다는 10분의 1정도 적은 시간
    - **Transfer Time**
        - 실제로 데이터를 전송하는 시간
        - 굉장히 작은 시간 차지
    
    👉 한 번의 seek로 많은 양을 읽고 쓰는 것이 효율적
    
- **Disk Bandwidth**
    - 단위 시간 당 전송된 바이트 수
- **Disk Scheduling**
    - seek time (seek distance) 을 최소화하는 것이 목표
    

> 디스크 스케줄링 알고리즘이 구현된 곳은 대부분 디스크 내부 ❌ 운영체제 쪽에 존재 ⭕ 따라서 정확한 디스크 상의 위치는 모를 수 있으며, 주로 논리 블럭 번호를 보고 스케줄링을 진행하게 된다.
> 

### 🔽 Example

*실린더 위치(번호) 는 0~199까지 존재*

*디스크 헤드 53번에서 시작한 각 알고리즘의 수행 결과는?*

*98 183 37 122 14 124 65 67*

### 1️⃣ FCFS

- First Come First Service
- **안쪽 - 바깥쪽 트랙의 요청이 번갈아 오게 될 경우 디스크 헤드가 상당히 많이 움직여야 하는 문제점 발생**
- 헤드의 이동 거리가 길어질 경우 대단히 비효율적
- *53 → 98 → 183 → 37 → 122 → 14 → 124 → 65 → 67 (head의 이동 640 cylinders)*

### 2️⃣ SSTF

- Shortest Seek Time First
- 현재 헤드 위치에서 가장 가까운 요청을 먼저 처리
- **starvation이 발생할 수 있는 문제**
- *53 → 65 → 67 → 37 → 14 → 98 → 122 → 124 → 183 → 199 (236 cylinders)*

### 3️⃣ SCAN

- 엘리베이터 스케줄링
- 큐에 어떤 요청이 들어왔는지 상황에 상관 없이 disk arm이 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리
- **다른 한쪽 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동**
- 디스크 헤드의 이동 거리 측면에서 효율적이면서도 공정한 편이나 **실린더 위치에 따라 대기 시간이 다르다는 문제** *(가운데 부분은 양쪽 가장자리 끝 부분에 비해 기다리는 시간의 예상 기대치가 짧음)*
- *53 → 37 → 14 → (0) → 65 → 67 → 98 → 122 → 124 → 183 → (199) (208 cylinders)*

### 4️⃣ C-SCAN

- Circular SCAN
- 헤드가 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리
- **다른쪽 끝에 도달했으면 요청을 처리하지 않고 곧바로 출발점으로 다시 이동**
- SCAN에 비해 이동 거리는 조금 길어질 수 있으나 **SCAN 보다 균일한 대기 시간을 제공**
- *53 → 65→ 67 → 98 → 122 → 124 → 183 → 199 → 0 → 14 → 37*

### 5️⃣ N-SCAN

- 일단 arm이 한 방향으로 움직이기 시작하면 그 시점 이후(즉, 지나가는 도중)에 도착한 job은 이번에 처리하지 않고 되돌아올 때 service
- **요청들의 대기 시간의 편차를 좀 더 줄일 수 있음**

### 6️⃣ LOOK

- 요청이 있든 없든 끝에서 끝으로 이동하는 **SCAN, C-SCAN을 개선**
- **가던 방향에 더 이상 요청이 없을 경우 그 지점에서 방향을 바꿈**

### 7️⃣ C-LOOK

- *53 → 65 → 67 → 98 → 122 → 124 → 183 → (199 가지 않고 바로 방향 돌림 0번까지 이동하지 않고 요청이 있는 지점 중 제일 낮은 주소까지 이동) → 14 → 37*

### 📂 Disk Scheduling Algorithm의 결정

- 현대에서는 주로 디스크 헤드의 이동 거리를 줄일 수 있는 SCAN, C-SCAN 주로 사용 또는 그 응용 LOOK, C-LOOK 사용
- 파일의 할당 방법에 따라 디스크 스케줄링 성능 영향

*ex. 연속 할당 방법 → 연속된 위치에 있기 때문에 이동 거리를 줄일 수 있는 반면 산발적 할당 시 헤드의 이동 거리가 길어질 수 있음* 

- 머징을 통해 한꺼번에 처리하기도 함 → 그때 그때 요청들을 개별적으로 처리하기 보다는 여러 요청들을 묶어서 한꺼번에 처리하여 디스크 I/O의 효율성을 높임
- 디스크 스케줄링 알고리즘은 필요할 경우 다른 알고리즘으로 쉽게 교체할 수 있도록 운영체제와 별도의 모듈로 작성되는 것이 바람직

### 📂 Swap-Space Management

- 하드디스크(보조기억장치)를 사용하는 이유
    - **메모리의 휘발성** volatile한 특성 *(DRAM은 전원이 나가면 사라짐)*
        - 파일시스템과 같이 영속적으로 데이터를 유지해야하는 부분은 DRAM에 유지 ❌
    - 프로그램 실행을 위한 **메모리 공간 부족**
        - swap space/area 필요 메모리의 연장 공간으로 사용
- **Swap-Space**
    
    > *하드디스크 차원에서는 어떻게 관리되어야 하는가*
    > 
    - 물리적 디스크를 파티셔닝 하면 Logical Disk를 만들 수 있음
    - 운영체제는 각각의 Logical Disk를 독립적 디스크로 여겨 각각을 file system 또는 swap area로 사용 가능
        - file system은 주로 512바이트의 섹터 단위로 데이터 저장 공간 효율성 중요 ⭕
        - swap area는 프로그램이 끝나면 어차피 사라질 내용이므로 공간 효율성은 별로 중요 ❌ 디스크로 빨리 쫓아내고 다시 또 메모리로 빨리 올리고 디스크 접근 시간 seek time 줄이는 것이 중요 ⭐ 👉 속도 효율성 큰 단위를 순차적으로 할당, 512Kbyte 대용량의 단위로 올리고 내림, 경우에 따라서는 크기가 다르게 하기도 함!

### 📂 RAID

- Redundant Array of Independent Disks
- 여러 개의 디스크를 묶어서 사용
- 중복 저장 분산 저장
- **디스크 처리 속도 향상**
    - 여러 디스크에 block의 내용을 분산 저장
    - 여러 디스크가 협력하여 병렬적으로 읽어오기 때문에 빠른 서비스 기대 가능
    - **interleaving, striping**
- **신뢰성 향상**
    - 동일 정보를 여러 디스크에 중복 저장
    - 하나의 디스크가 고장 시 다른 디스크에서 읽어올 수 있음
    - **mirroring, shadowing**
    - 단순한 중복 저장이 아니라 일부 디스크에 **parity(중복 저장의 정도를 오류가 생겼는지 알아내고 복구할 수 있을 정도로 낮게 함)**를 저장하여 공간의 효율성을 높일 수 있음
