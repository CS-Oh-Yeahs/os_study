# File and File System

## File

- 관련 정보를 이름으로 저장하는 것
- 비휘발성의 보조기억장치(예. 하드디스크)에 저장
- 운영체제는 다양한 저장 장치를 file이라는 동일한 논리적 단위로 보고 관리한다. - device special file ⇒ 일반적인 파일 개념과는 다소 다름
- 관련 연산
    - create, read, write, reposition(lseek), delete, open, close 등
    - reposition : 파일의 위치를 수정해주는 연산
    - open : 파일의 metadata를 메모리에 올려놓는 작업

## File attribute(metadata)

- 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들
    - 파일 이름, 유형, 저장된 위치, 파일 사이즈 등
    - 접근 권한(읽기/쓰기/실행), 시간(생성/변경/사용), 소유자 등

## File system

- 운영체제에서 파일을 관리하는 부분
- 파일 및 파일의 메타데이터, 디렉토리 정보 등을 함께 관리
- 파일의 저장 방법 결정
- 파일 보호 등을 담당

# Directory and Logical Disk

## Directory

- 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일
- 그 디렉토리에 속한 파일 이름 및 파일의 attribute들을 보관
- 관련 연산
    - search for a file, create a file, delete a file
    - list a directory, rename a file, traverse(탐색) the file system

## Partition(=Logical Disk)

- 운영체제가 보는 논리적 디스크
- 하나의 물리적 디스크 안에 여러 파티션을 두는 것이 일반적
- 여러 개의 물리적인 디스크를 하나의 파티션으로 구성하기도 한다.
 (디스크 하나를 사서 C드라이브, D드라이브로 나눌 때 C/D 드라이브들을 말한다.)
- 물리적 디스크를 파티션으로 구성한 뒤 각각의 파티션에 file system을 설치하거나 swapping(swap area) 등 다른 용도로 사용할 수 있다.

---

# 파일 관련 연산들

## Open(”/a/b/c”)

![파일 시스템-open작업](https://user-images.githubusercontent.com/90598889/163717861-6ad71d64-fd76-437a-9075-dd3f9599d040.jpg)

- 위의 연산 수행 과정에서 디스크로부터 파일 c의 메타데이터를 메모리로 가지고 온다.
    - 이를 위해 directory 경로를 탐색한다.
        - 루트 디렉토리인 “/”을 open하고 그 안에서 파일 “a”의 위치를 획득한다.
        - 파일 “a”를 open한 후 read하여 그 안에서 파일 “b”의 위치를 획득한다.
        - 파일 “b”를 open한 후 read하여 그 안에서 파일 “c”의 위치를 획득한다.
        - 파일 “c”를 open한다.
- Directory경로의 탐색에 너무 많은 시간이 소요된다.
(open을 read/write와 별도로 두는 이유)
- 한 번 open한 파일은 read/write 시 directory 탐색이 불필요하다.

### Open file table

- 메모리 내에 위치하고 있는 현재 open된 파일들의 메타데이터를 보관하는 장소
- 디스크의 메타데이터보다 몇 가지 정보가 추가되어 저장되어 있다.
    - open한 프로세스의 수
    - file offset : 파일 내용 중 어느 위치에 접근 중인지

### File descriptor(file handler, file control block)

- open file table에 대한 위치 정보
- 프로세스 별로 존재한다.
- 결과값은 메모리 내의 커널 영역에 있는 PCB에서 b의 메타데이터의 위치를 가리키는 포인터 값을 메모리 내의 사용자 영역에 반환하게 된다.

### Buffer Caching

- 운영체제가 메모리 내의 커널 영역에 파일 시스템으로부터 읽어 온 어떤 파일의 메타 데이터를 저장해 두었다가 이후 같은 파일에 대한 요청이 있을 때 해당 데이터를 전달해주는 것

---

# File Protection

- 각 파일에 대해 누구에게 어떤 유형의 접근을 허락할 것인가?

## 접근 권한 제어 방법

### Access control Matrix

- 행렬의 행과 열(행 - 사용자 / 열 - 파일 종류)에 사용자가 획득한 권한을 표시해두는 방법
- 그러나 만약 다른 사용자에게 권한이 없는 파일 종류들에 대해서도 같은 방법으로 행렬을 통해 표시한다면 쓰이지 않는 행렬 공간이 생기게 된다. 이를 보완하기 위해 아래와 같이 주체를 구분한 링크드 리스트 형태로 저장하는 방법이 있다.
    - Access control list : 파일을 주체로 하고, 파일별로 누구에게 어떤 접근 권한이 있는지 표시
    - Capability : 사용자를 주체로 하여 사용자별로 자신이 접근 권한을 가진 파일 및 해당 권한을 표시
    
    ⇒ 위 방법들 중 한 가지만 쓰면 된다.
    

⇒ 모든 사용자들과 모든 파일에 대해 접근 권한을 제어할 수 있다.

### Grouping

- 모든 사용자에 대해 접근 권한을 다루는 것이 아닌 각각의 파일에 대해 사용자 그룹을 세 가지(Owner-소유주, group-동일그룹에 속한 사용자들, public-나머지 전체 외부 사용자)로 나누어 관리하는 방법
- 각 파일에 대해 세 그룹의 접근 권한(rwx)을 3비트씩 표시하여 총 9비트의 공간만이 필요하다.

### Password

- 파일마다 패스워드를 걸어 관리하는 방법. 디렉토리에 패스워드를 둘 수도 있다.
- all-or-nothing : 모든 접근 권한에 대해 하나의 패스워드를 두는 것

## File System의 Mounting - 어떠한 것을 이용가능한 상태로 만드는 것

- 디스크와 같은 물리적인 장치를 특정 위치 즉, 디렉토리에 연결시켜주는 것
- 다른 파티션에 설치되어 있는 파일 시스템에 접근하고자 할 경우 마운트를 이용하여 접근할 수 있다.
- 보통 윈도우 운영체제는 이러한 작업을 내부적으로 자동으로 해주기 때문에 사용자가 직접 할 필요는 없지만 리눅스의 경우 시스템 자체가 Unix 시스템으로, 윈도우와는 다르게 하나의 디렉토리부터 뻗어지는 single directory tree구조를 갖고 있다. (접근 가능한 모든 저장공간의 뿌리가 하나의 디렉토리랑 연결되어 있다는 의미. 윈도우는 C, D, E드라이브 이런식으로 분리되어 구성되어 있다.) 따라서 리눅스에서는 root 시스템에 접근하고자 하는 파일을 마운트해주어야 해당 파일에 접근할 수 있다.
- root file system의 특정 디렉토리 이름에 다른 파티션에 있는 파일 시스템을 마운트하면, 이는 곧 해당 파일 시스템의 root file system에 접근하는 것과 같다.

## 이 외 접근 방법

- 만약 a/b/c 순서로 저장되어 있는 파일이 있을 경우
- 매체에 따라 아래와 같은 방식으로 접근이 가능하다.

### 순차 접근(sequential access)

- 카세트 테이프를 사용하는 방식처럼 접근하는 것
- 읽거나 쓰면 offset은 자동적으로 증가한다.
- 위의 예시에서 c를 접근하고자 할 경우, a, b를 각각 거쳐서 접근해야 한다.

### 직접 접근(direct access, random access)

- LP 레코드 판과 같이 접근하도록 하는 것
- 파일을 구성하는 레코드를 임의의 순서로 접근할 수 있다.
- 위의 예시에서 c를 접근하고자 할 경우, a, b를 거치지 않고도 접근할 수 있다.
- 그러나 직접 접근만이 가능한 매체에서도 데이터를 어떻게 관리하느냐에 따라 순차 접근이 가능해질 수도 있다. (👇아래에서 계속)

---

# File System Implementation

# 디스크에 파일의 데이터를 저장하는 방법

- 임의의 크기의 파일을 동일한 크기의 블록 단위로 나누어 저장한다.

## 연속 할당 방법(Contiguous Allocation)

- 하나의 파일이 디스크 상에 연속적으로 저장되는 방법
여러 개의 블록이 연속적으로 저장된다.
    
    ### 장점
    
    - 빠른 입출력이 가능하다.
        - 하드디스크와 같은 매체는 대부분의 소요 시간이 디스크 내의 헤드가 이동할 때 소요되는데 연속 할당의 경우 한번의 seek와 그 이후의 rotation으로 많은 바이트들을 transfer할 수 있다.
        - realtime용으로 또는 이미 실행중이던 프로세스의 swapping 용으로 사용할 수 있다.
    - 파일의 데이터가 블록 단위로 나누어 저장되어 있기 때문에 접근하길 원하는 내용에 대해 직접 접근이 가능하다.
    
    ### 단점
    
    - 외부 조각이 생성될 가능성이 있다.
    (각각의 파일 크기가 다르기 때문)
    - 파일 크기가 커질 수도 있는데 이러한 상황에서 제약이 생길 수 있다.
        - 이를 보완하기 위해 파일 크기가 커질 때를 대비해 빈 블록들을 확보해두는 방법을 생각해볼 수 있는데, 이런 경우에는 또 내부조각이 생성될 수 있다.
        - 중간중간 hole이 생길 수 있다.

## 연결 할당 방법(Linked Allocation)

- 파일의 데이터를 링크드 리스트처럼 포인터를 이용해 산발적으로 흩어져 있는 블록들에 저장하는 방법
- 파일의 시작 위치만 디렉토리가 갖고 있고, 이후 블록들의 위치는 이전 블록들에 기록되어 있다.
    
    ### 장점
    
    - 외부 조각이 발생하지 않는다.
    
    ### 단점
    
    - 직접 접근이 되지 않는다. 중간중간 이어지는 블록들을 모두 지나야 원하는 블록으로 이동할 수 있다.
    - reliability 문제
        - 중간 블록이 bad sector일 경우, 포인터가 유실되어 뒷 부분의 블록을 더이상 탐색할 수 없게되는 문제
    - 블록의 일부에 포인터를 위한 공간을 확보해야하므로, 공간상의 효율성을 떨어뜨린다.
        - 512byte 중 4byte를 포인터를 위해 남겨두어야 한다.
    
    ### 연결 할당 방법의 변형
    
    - **FAT(File-Allocation-Table)** 파일 시스템
        - 포인터를 별도의 위치에 보관하여 reliability문제와 공간상의 비효율성 문제를 해결한 방법

## Indexed Allocation

- 디렉토리에 index block이 있고, 해당 블록에 나머지 파일 데이터 블록들의 시작 위치를 기록해두는 방법
    
    ### 장점
    
    - 외부 조각이 생기지 않는다.
    - 직접 접근이 가능하다.
    
    ### 단점
    
    - 아무리 작은 파일이라 하더라도 블록이 2개 이상 필요하다. 따라서 파일이 굉장히 작은 경우 공간 낭비가 발생한다.
    (실제로 많은 파일들의 사이즈가 작다.)
    - 굉장히 큰 파일의 경우 하나의 인덱스 블록으로 다른 블록들의 인덱스를 다 담지 못하게 된다.
        - linked scheme - 하나의 인덱스 블록과 연결되는 또 다른 인덱스 블록을 사용하는 것
        - multi-level index - 하나의 인덱스 블록이 직접 파일의 위치를 가리키는 것이 아닌 2단계 페이지 테이블에서처럼 또 다른 파일의 인덱스를 가리키도록 하는 방법을 사용하여 보완할 수 있다.

---

실제 파일 시스템에서 어떤 방법을 어떻게 변형하여 사용하는지

# Unix의 파일시스템 구조

![unix 파일 시스템 구조](https://user-images.githubusercontent.com/90598889/163717883-14a5fdf3-a955-4aff-8325-a622c8e91899.jpg)

## Boot block - 어떤 파일 시스템이라도 0번째에 있는 블록

- 부팅에 필요한 기본 정보를 저장한 블록(bootstrap loader)
- 운영 체제의 커널 위치를 담고 있다.

## Super block

- 파일 시스템에 관한 총체적인 정보(빈 블록 정보, 사용중인 블록에 대한 정보, Inode list의 위치 등)를 담고 있다.

## Inode list

- Inode : 인덱스 노드
- 파일 하나당 Inode 하나씩 할당되어, 해당 파일의 메타 데이터를 가지고 있다.
- directory에는 파일의 메타데이터 중 일부만 보관한다. 이 중, 파일의 이름과 Inode의 번호를 directory가 갖고 있다.
- Inode의 크기는 고정되어 있다. 따라서 위치 정보를 나타내는 포인터의 개수도 유한하다.
    - 그러나 파일의 위치 정보를 direct block, single/double/triple indirect 총 4가지로 구성해서 파일 크기에 따라 위에서부터 차례로 포인터를 할당하면서 위치 정보를 저장한다.
    - 대부분의 크기는 파일의 크기가 굉장히 작아서 direct block으로 대체로 처리할 수 있다.

---

# FAT File System 구조

![fat file system](https://user-images.githubusercontent.com/90598889/163717909-eb4900da-68c3-4b96-9a2a-1d7729591a07.jpg)

- 최근 윈도우즈, 모바일 기기에서도 사용하는 경우도 있다.

## FAT

- 디스크가 관리하는 data block의 개수만큼의 크기로 생성되어 있는 배열이다.
- 파일의 메타데이터 중 일부(위치 정보)를 해당 공간에 보관한다.
- 나머지 메타데이터들(이름, 첫번째 위치 등)은 모두 directory가 보관한다.
- 각 index는 파일 블록의 시작 위치를 가리키고 해당 인덱스의 원소는 다음 블록의 위치를 저장하고 있다.
- linked allocation 방식을 활용하였지만 fat만 확인하여 블록들의 다음 위치를 바로바로 확인할 수 있게 한 것이다.
- 직접 접근이 가능하다.
- 중요한 정보를 담고 있기 때문에 디스크에 2copy 이상을 저장하고 있다.
- Linked allocation의 단점을 보완한 방법이다.
    - 포인터 하나가 유실되더라도 fat에 그 내용이 있기 때문에 이후에 존재하는 나머지 파일 내용들을 읽지 못하는 상황을 방지할 수 있다.

---

비어있는 파일 블록을 관리하는 방법

# Free-Space Management

## Bit map or bit vector

- 데이터 블록 내의 블록들이 비어있는 공간인지 아닌지를 0/1로 표시하는 방법
- 디스크 내에 부가적인 공간을 필요로 한다.
- 연속적인 n개의 비어있는 블록을 찾는데에 효과적이다.

## Linked list

- 비어있는 블록들을 링크드 리스트 형태로 연결해놓는 방법
- 비어있는 첫번째 블록의 위치만 포인터로 알고 있고 이후 블록들은 직전 블록 내에 포인터가 저장되어 있다.
- 공간의 낭비가 없지만 연속적인 빈 블록을 찾기에는 어려움이 있다.

## Grouping

- linked list 방법을 변형하여 첫번째 비어있는 블록이 인덱스 역할을 해서 해당 블록 내에는 비어있는 블록에 대한 포인터들이 쭉 저장되어 있는 형태
- 비어있는 블록을 한꺼번에 찾기에는 linked list보다는 효율적이지만 연속적인 빈 블록을 찾기에는 다소 효과적이지 않다.


## Counting

- 연속적인 빈 블록을 표시하기 위해 빈 블록의 첫번째 위치와 이로부터 몇 개가 빈 블록인지에 대한 정보를 쌍으로 관리하는 방법

---

# Directory Implementation-디렉토리의 구현

- 디렉토리 파일에 내용을 저장하는 방법

## Linear List

- [file name, file metadata] 의 리스트 형태로 저장하는 방법
- 구현이 간단하다.
- 디렉토리 내에 파일이 있는지 찾기위해서는 linear search가 필요하다. 모든 리스트 원소를 다 탐색해야 하기 때문에 시간이 많이 소요하다.

## Hash Table

- 파일의 이름을 그냥 저장하는 것이 아닌 해쉬 함수를 적용하여 저장하는 방법
- 어떤 파일의 내용을 찾고자 할 때, 순차적으로 탐색하지 않고 파일의 이름을 해쉬 함수로 변환하고 해당 해쉬 함수에 해당하는 엔트리만 찾아내면 된다. ⇒ 탐색 시간을 줄인다.
- 서로 다른 파일 이름이 같은 해쉬값으로 변환되었을 경우 충돌 문제가 발생한다.

## 파일의 메타데이터 보관

- 디렉토리 내에 직접 보관하는 방법
- 디렉토리에는 포인터를 두고 inode나 fat등 다른 곳에 보관하는 방법

## 긴 파일 이름을 지원하는 방법

- [file name, file metadata] 로 구성된 리스트에서 각 엔트리는 일반적으로 그 크기가 고정되어 있다.
- 파일 이름이 고정된 크기의 엔트리보다 길어지는 경우 엔트리의 마지막 부분에 이름의 뒷부분이 위치한 곳의 포인터를 두고, 이름의 나머지 부분은 동일한 directory file의 일부에 둔다.

---

# VFS and NFS

![VFS, NFS](https://user-images.githubusercontent.com/90598889/163717931-54ac9728-0ad2-4bc2-8dd3-b39d284e4214.jpg)

## VFS(Virtual File System)

- 사용자가 파일 시스템에 접근하기 위해서는 시스템 콜을 해야한다. 그런데 서로 다른 파일 시스템 별로 서로 다른 시스템 콜을 해야한다면, 이 경우는 사용상의 번거로움이 너무 크다.
- 이를 예방하기 위해 서로 다른 다양한 파일 시스템에 대해 동일한 시스템 콜 인터페이스를 통해 접근할 수 있게 해주는 OS의 한 계층으로서 VFS Interface가 존재한다.

## NFS(Network File System)

- 분산 시스템에서는 네트워크를 통해 파일이 공유될 수 있다. NFS는 분산 환경에서의 대표적인 파일 공유 방법이다.

---

# Page Cache and Buffer Cache

![page cache and buffer cache](https://user-images.githubusercontent.com/90598889/163717964-3200e0b8-fc93-4c1e-b9b8-2fa4da0112c6.jpg)

## Page Cache

- 가상 메모리의 페이징 시스템에서 사용하는 페이지 프레임을 지칭하는 용어
- Memory-Mapped I/O를 쓰는 경우 파일의 I/O에서도 페이지 캐시를 사용한다.
- 운영체제에게 제공되는 정보가 지극히 제한적이다. 메모리 내에서는 하드웨어적인 처리가 주요하기 때문이다.
- 단위 : 페이지

## Memory-Mapped I/O

- 파일의 일부를 가상 메모리에 매핑 시킨다.
- 매핑시킨 영역에 대한 메모리 접근 연산은 파일의 입출력을 수행하게 한다.
- 대표적인 예시
    
    ![프로그램의 실행](https://user-images.githubusercontent.com/90598889/163717981-2969f55b-35d7-4049-8b51-b85ab0899e88.jpg)
    
    - 실행파일의 코드 부분은 메모리에 올라갔다가 쫓겨날 경우 swap area에 넘어가지 않는다.
    - 실행 파일을 실행시킬 때 loader 라는 소프트웨어가 실행 파일의 코드 부분은 memory-mapped i/o 방식을 통해 메모리에 올린다.
    - 파일 형태의 내용이 프로세스의 주소 영역에 mapping되어 어떤 코드가 메모리에 올라와 있지 않은 경우 swap에서 찾는 것이 아닌 실행파일에서 찾게 된다.
- 메모리에 올라온 파일의 내용은 시스템 콜을 하지 않고 자신이 직접 cpu를 가지고 있으면서 직접 접근을 할 수 있기 때문에 더 빠르다는 장점이 있다.
- 캐시에 올라온 내용을 자신의 주소 공간으로 카피하지 않기 때문에 오버헤드가 발생하지 않는다.
- 그러나, 여러 프로세스가 동시에 같은 내용을 쓰게 될 경우 카피가 아닌 매핑으로 해당 내용은 동일한 내용들이기 때문에 데이터의 일관성이 지켜지지 않을 수 있다.

## Buffer Cache

- 파일시스템을 통한 I/O연산은 메모리의 특정 영역인 Buffer Cache를 사용한다.
- 파일 사용의 locality를 활용한다.
    - 한번 읽어온 블록에 대한 후속 요청 시 buffer cache에서 즉시 전달한다.
- 모든 프로세스가 공용으로 사용한다.
- replacement algorithm 이 필요하다. (LRU, LFU 등)
- 단위 : 최근에 unified buffer cache로 통합되면서 페이지 단위로 캐싱된다.

## Unified Buffer Cache

- 최근의 os 에서는 기존의 buffer cache가 page cache 가 통합되었다.
- 버터 캐쉬도 페이지 단위로 관리하는 것
