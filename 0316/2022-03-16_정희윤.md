# 🔷프로세스

## 1️⃣ 프로세스의 문맥

- 프로세스가 현재 어떤 상태에서 수행되고 있는지 규명하기 위해 필요한 정보
- CPU를 빼앗겼다가 다시 획득해 명령의 수행을 재개하는 시점이 되면 이전에 어느 부분까지 명령을 수행했는지 직전 수행 시점의 정확한 상태를 재현하기 위해 필요

### 하드웨어 문맥

- CPU의 수행상태를 나타내는 것
- CPU의 **프로그램 카운터**가 **프로그램 주소공간**의 코드에서 어딜 가리키고 있는지
- CPU의 **레지스터**에는 어떤 값이 있고, 어떤 Instruction까지 수행했는지

### 프로세스의 주소 공간

![프로세스 주소 공간](https://user-images.githubusercontent.com/90598889/160350358-c8586034-1787-475b-818a-8815e4216485.jpg)

- 프로세스는 ‘코드, 데이터, 스택’으로 구성되는 자기 자신만의 독자적인 주소 공간을 갖는다.
- data에는 어떤 주소가 있는지, stack에는 어떤 함수의 결과값이 쌓여 있는지에 대한 정보를 저장하고 있다.

### 프로세스 관련 커널 자료 구조(커널상의 문맥)

- 운영체제가 프로세스를 관리하기 위해 유지하는 자료구조에는 자신의 data영역에 두는 **PCB**와 커널의 스택에 저장되는 프로세스의 **커널스택**이 있다.
- kernel stack(커널스택)
    - 커널의 code는 다수의 프로세스가 사용할 수 있기 때문에 각 프로세스마다 stack를 별도로 두고 있다.
    - 따라서 프로세스의 현재 상태를 커널의 스택을 통해서도 알 수 있다.

---

## 2️⃣ 프로세스의 상태

- 컴퓨터의 자원을 효율적으로 관리하기 위해 프로세스의 상태를 구분한다.

![프로세스 상태도](https://user-images.githubusercontent.com/90598889/160350485-52ac31e8-6d44-44ab-a6c6-a1aa0a335d64.jpg)

### 실행(Running)

- 프로세스가 CPU를 보유하고 기계어 명령(Instruction)을 실행중인 상태

### 준비(Ready)

- 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
- 메모리 등 다른 조건을 모두 만족하고 CPU를 기다리는 상태

### 봉쇄(Blocked)

- CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태
- 프로세스 자신이 요청한 이벤트가 즉시 만족되지 않아 이를 기다리는 상태
예) 디스크에서 파일을 읽어와야 하는 경우

### 중지(Suspended)

- 외부적인 이유로 프로세스의 수행이 정지된 상태
- 중기 스케쥴러에 의해 프로세스가 통째로 디스크로 swap out 된 경우
⇒ 해당 프로세스들은 메모리를 조금도 보유하지 않게 된다.
- 사용자가 프로그램을 일시 정지시킨 경우(Break key) ⇒ 사람이 프로세스를 다시 실행시켜주어야 다시 준비상태로 갈 수 있다.

<details>
    <summary><h3>중지 상태의 종류</h3></summary>
<div markdown="1">       

<h3>중지준비</h3>

- <b>준비 상태</b>에 있던 프로세스가 중기 스케쥴러에 의해 디스크로 스왑 아웃된 경우

<h3>중지봉쇄</h3>

- <b>봉쇄 상태</b>에 있던 프로세스가 중기 스케쥴러에 의해 디스크로 스왑 아웃된 경우

</div>
</details>


### 봉쇄 VS 중지

- 자신이 요청한 이벤트(I/O 요청)가 만족될 경우 봉쇄
- 외부에서 프로세스를 중지시킨 경우 중지

<details>
    <summary><h3>Cf) 시작 상태, 완료 상태</h3></summary>
<div markdown="1">       

<h3>시작(New) 상태</h3>

- 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태

<h3>완료(Terminated) 상태</h3>

- 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

</div>
</details>

![프로세스 상태](https://user-images.githubusercontent.com/90598889/160352288-5df3effc-ba2c-493b-b8f9-c410bbab534e.jpg)

---

## 3️⃣ PCB(Process Control Block : 프로세스 상태 블록, 제어 블록)

- 운영체제가 각 프로세스를 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조

![프로세스 제어블록](https://user-images.githubusercontent.com/90598889/160352396-68f10221-966c-4642-be13-eaf4b387a467.jpg)

### 구성요소

- OS가 관리상 사용하는 정보
    - 프로세스 상태(process state)
    - CPU 스케쥴링 정보(CPU scheduling information)
- CPU 수행 관련 하드웨어 값
    - 프로그램 카운터(Program counter)의 값 : 다음에 수행할 명령의 위치
    - CPU 레지스터(CPU register)의 값 : CPU연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지
- 메모리 관련
    - 메모리 관리 정보(memory management information) : 메모리 할당을 위해 필요한 정보
    - 자원 사용 정보(accounting information) : 자원 사용 요금 청구를 위한 정보
- 파일 관련
    - 입출력 상태 정보(I/O status information) : 프로세스의 입출력 관련 상태 정보

---

## 4️⃣ 컨텍스트 스위칭(문맥 교환) - 아주 중요

- CPU를 **한 프로세스에서 다른 프로세스로** 넘겨주는 과정
- 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정
- 발생 상황
    - 타이머 인터럽트가 발생했을 경우
    - 실행 중이던 프로세스가 입출력 요청을 하여 봉쇄 상태가 되는 경우
    - 실행 중이던 프로세스가 다른 조건을 만족하지 못하여 봉쇄 상태가 되는 경우
- 문맥 교환 시 필요한 작업
    - 커널 Data의 프로세스A의 PCB에 문맥을 저장
    - 저장했던 프로세스 B의 PCB를 하드웨어에 넘겨줌
- ❗중요❗
    - CPU가 사용자 프로세스로부터 운영체제로 넘어가는 것은 컨텍스트 스위치가 아니라 단지 실행 모드가 사용자모드에서 커널모드로 바뀌는 것이다.
    - 컨텍스트 스위치는 CPU를 점유하는 한 프로세스가 다른 프로세스로 바뀔 때 발생한다.

### CPU Dispatch(CPU 디스패치)

- 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정

---

❓ **[A, B 프로세스 예시(책 p117 ~ 118)]**

- 프로세스 A, 프로세스 B 존재
- 프로세스 A가 CPU에서 실행 중에 I/O를 위한 시스템 콜 발생

|  | CPU 점유 | 프로세스 상태 | CPU의 프로세스 문맥 |
| --- | --- | --- | --- |
| P(A)의 I/O 시스템 콜 **이전** | P(A) | A : 실행<br>B : 준비 | P(A) |
| P(A)의 I/O 시스템 콜 **발생** | P(A) → P(B) | A : 봉쇄<br>B : 준비 → 사용자모드 실행 | P(A) → P(B) |
| P(A)의 I/O 시스템 콜 **처리 이후**<br>(=I/O 인터럽트 발생) | P(B) → 인터럽트 루틴 | A : 봉쇄 → 준비<br>B : 사용자모드 실행 → 커널모드 실행 | P(B)<br>(⇒ P(B)의 문맥을 유지) |
| CPU의 인터럽트 **처리 이후** | [일반적]<br>P(B)<br>[CPU 스케쥴링]<br>P(B) or P(A) | [일반적]<br>A : 준비<br>B : 커널모드 실행 → 사용자모드 실행<br>[CPU 스케쥴링]<br>A : 준비 → 실행<br>B : 실행 → 준비 |[일반적]<br>P(B)의 이전 문맥 (컨텍스트 스위칭 X)<br>[CPU 스케쥴링]<br>P(B) → P(A)로 컨텍스트 스위칭 발생 |

---

## 5️⃣ 프로세스 스케쥴링 큐

![프로세스 스케쥴링 큐](https://user-images.githubusercontent.com/90598889/160354201-b5a7ebda-6de2-43cd-8b43-22672d2c4d0a.jpg)

- 운영체제가 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐를 둔다.
- 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행한다.
- 큐에는 준비 큐, 장치 큐 외에 작업 큐도 존재한다.
    - 작업 큐는 시스템 내의 모든 프로세스를 관리하기 위한 큐로, 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속한다.
    - 작업 큐는 준비 큐와 장치 큐를 포함하는 넓은 개념이다.
- 큐헤더는 큐의 가장 앞부분을 말한다.
- 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하며 포인터를 사용해 순서를 정한다.

---

## 6️⃣ 스케쥴러

- 운영체제가 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널 내의 코드

### 장기 스케쥴러

- 작업 스케쥴러(Job Scheduler)라고도 한다.
- 시작(new)상태에 있는 프로세스 중 어떤 것들을 준비 큐(ready queue)로 보낼지를 결정하는 역할 ⇒ 프로세스에게 메모리를 할당하는 문제에 관여
- 멀티프로그래밍의 정도를 제어 ⇒ 메모리에 올라가있는 프로세스의 수를 제어
- 시분할 시스템에는 장기 스케쥴러가 없다. ⇒ 시분할 시스템은 어차피 프로그램이 시작될 때 메모리에 프로세스를 여러 개 올려놓기 때문

### 중기 스케쥴러

- 너무 많은 프로세스에게 메모리를 할당하여 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케쥴러
- 프로세스 당 메모리를 차지하는 양이 극도로 적어 프로세스의 주소 공간 조차 메모리에 올려 놓기 어려운 상황이 될 경우, 메모리에 올라와 있는 프로세스 중 일부에서 메모리를 빼앗아 디스크의 스왑 영역에 저장(스왑 아웃, Swap out)한다. 그래서 Swapper라고도 한다.
    - 스왑 아웃 순서
        - 0순위 : 봉쇄 상태의 프로세스들
        - 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스들
- 메모리에서 프로세스를 디스크로 쫓아냄으로써 멀티프로그래밍의 정도를 제어한다.

### 단기 스케쥴러

- CPU 스케쥴러라고도 한다.
- 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지를 결정한다. 
즉, CPU를 어떤 프로세스에 줄 지를 결정
- millisecond단위로 호출된다. ⇒ 실행속도가 매우 빨라야 한다.
- 시분할 시스템에서는 타이머 인터럽트가 발생할 경우 단기 스케쥴러가 호출된다.

---

## 7️⃣ 쓰레드(Thread)

- **프로세스 내부에 CPU 수행단위가 여러 개 있는 경우**
- 프로세스의 주소를 한 개만 띄워놓고 program counter만 여러 개로 두어
- 프로세스 하나에서 메모리 주소 공간과 프로세스 상태, 프로세스가 사용하는 각종 자원들만 공유하고 CPU수행과 관련된 정보(레지스터, 프로그램 카운터, 스택)와 같은 것들은 쓰레드들 각각이 별도로 가진다.
- CPU를 수행하는 단위
- lightweight process 라고도 한다.

### 쓰레드의 구성

- 프로그램 카운터
- 레지스터 셋(register set)
- 스택(stack space)

### 쓰레드가 동료 쓰레드와 공유하는 부분(task)

- code section
- data section
- OS resources

### 쓰레드의 장점 4가지

1. **응답성**
    - 하나의 프로세스 안에 쓰레드를 여러 개 둘 경우, 쓰레드 하나가 블록 상태일 때 다른 쓰레드는 CPU 실행 상태인 게 가능하다. 이 경우 더욱 빠른 실행이 가능하다.
        
        예) 브라우저에서 네이버 화면을 띄운다고 할 때, 멀티 쓰레드로 프로그램이 실행될 경우 네이버 화면에서 그림이 뜨는 동안 텍스트가 먼저 뜨게 되어 사용자에게 빠른 응답이 가능하게 된다.
        
2. **자원 공유**
    - 동일한 일을 수행하는 작업을 쓰레드끼리 공유하게 될 경우 자원을 절약하고 성능 향상의 효과를 얻을 수 있다.
    - 코드, 데이터, 각종 OS자원을 공유한다.
3. **경제성**
    - 프로세스를 여러 개 만드는 것에 비해 한 프로세스 내부에서 쓰레드를 여러 개 만드는 것이 훨씬 경제적이다.
    - 컨텍스트 스위칭의 경우에도 프로세스 간의 컨텍스트 스위칭보다 쓰레드끼리의 스위칭이 훨씬 경제적이다.
4. 멀티프로세서 아키텍쳐(CPU가 여러개) 하에서 **병렬성**
    - CPU가 여러 개 달린 컴퓨터의 경우, 병렬성을 높일 수 있다.
        
        예) 1000*1000 행과 열을 곱하게 될 경우 여러 쓰레드를 사용하여 계산된 결과를 합쳐서 그 결과를 더욱 빨리 도출할 수 있게 된다.
        

### 개괄적인 쓰레드 구현 방법

- 커널 쓰레드
    - 쓰레드가 여러 개 있다는 사실을 운영체제 커널이 알고 있다.
    - 쓰레드가 넘어가는 것도 커널이 CPU 스케쥴링을 하듯이 넘겨주게 된다.
- 유저 쓰레드
    - 라이브러리를 통해서 지원된다.
    - 프로세스 안에 쓰레드가 여러개 있다는 사실을 운영체제는 모른다.
    - 프로세스 본인이 내부에서 CPU 수행단위를 여러 개 두면서 쓰레드를 운영한다.
- real time 쓰레드

---

<details>
    <summary><h3>스터디 질문 모음</h3></summary>
<div markdown="1">       

<h3>Q1. 프로세스와 스레드 각각의 개념을 설명하고, 멀티프로세스보다 멀티스레드가 효율적인 이유를 말씀해주세요.</h3>

프로세스는 CPU에서 실행중인 프로그램을 의미하고 스레드는 한 프로세스 내에서 CPU 사용 단위가 여러 개인 경우를 의미한다. 여러 개의 스레드는 한 프로세스 내에서 data, code, OS의 자원과 같은 영역들을 공유하되 CPU사용과 관련된 정보들를 별도로 갖는다. 반면 멀티 프로세스 하에서 프로세스들은 각각의 프로세스들이 별도로 자원 및 CPU를 사용하기 때문에 성능 향상 및 경제성 측면에서 멀티 스레드가 더욱 효율적이다.

<h3>Q2. 스레드의 장점을 아는 대로 전부 말씀해주세요.</h3>

스레드는 한 프로세스 내에서 CPU를 다양하게 활용할 수 있기 때문에 응답이 빠르고, 스레드끼리 코드/데이터/OS자원과 같은 자원들을 공유함으로써 자원 절약 및 성능 향상에 효과적이며 경제적이라는 장점이 있다. 더불어 멀티프로세스 환경 하에서 스레드는 병렬성이 높아져 작업 처리를 훨씬 빨리 할 수 있게 된다.

<h3>Q3. 프로세스 문맥교환이 어떠한 상황에서 발생하는지 설명해주세요.</h3>

프로세스 문맥교환은 CPU를 점유하는 프로세스가 A에서 B로 바뀔 때 발생한다. 이러한 상황의 예시로는 타이머 인터럽트가 발생했을 경우와 실행 중이던 프로세스가 입출력 요청에 의해 봉쇄 상태로 바뀌어 대기 중이던 프로세스가 CPU를 점유하게 되었을 경우 등이 있다

<h3>Q4. 적은 양의 메모리를 많은 프로세스에게 할당할 때 발생하는 문제점과 이를 해결하기 위해 개발된 스케줄러를 하나만 선택하여 설명해주세요.</h3>

적은 양의 메모리를 많은 프로세스에게 할당할 때, 메모리에 프로세스의 주소 공간조차 올리지 못하는 경우가 발생하게 되고 시스템의 전체적인 성능이 저하된다. 따라서 이러한 문제점을 해결하기 위해 메모리를 차지하는 프로세서들의 수를 동적으로 제어하는 중기 스케쥴러가 개발되었다. 이 스케쥴러는 봉쇄 상태의 프로세스들과 준비 상태의 프로세스들을 차례로 디스크의 스왑 공간에 스왑 아웃 처리하여 메모리에 적정 수의 프로세스들이 올라와 있을 수 있도록 한다.

<h3>Q5. 프로세스 제어블록이란 무엇인지 설명하고 프로세스 제어블록의 요소들에 대해 아는대로 말씀해주세요.</h3>

프로세스 제어블록 즉, PCB란 운영체제가 프로세스들을 관리하기 위해 각 프로세스들에 대한 정보들을 담고 있는 커널 내의 자료구조이다. 제어블록의 요소에는 포인터, 프로세스의 상태, CPU 레지스터의 값, CPU의 스케쥴링 정보, 프로그램 카운터의 값, 메모리 관리 정보 등이 있다. 

<h3>Q6. 4가지의 프로세스 상태에 대해 각각 설명해주세요.</h3>

프로세스 상태는 준비, 실행, 중지, 봉쇄 4가지로 구분할 수 있다. 준비는 CPU를 당장 사용해도 될 준비가 된 상태에서 CPU를 할당받기 위해 기다리는 상태이고 실행은 CPU를 점유하여 명령을 실행중인 상태이다. 중지는 외부 요인에 의해 CPU를 사용하지 못하게 된 상태이고, 봉쇄는 입출력 시스템 콜을 발생시키는 등 CPU를 할당받더라도 당장 명령을 수행할 수 없는 상태를 말한다.

</div>
</details>
