## 프로세스의 문맥

### 하드웨어 문맥

- CPU의 **프로그램 카운터**가 **프로그램 주소공간**의 코드에서 어딜 가리키고 있는지
- CPU의 **레지스터**에는 어떤 값이 있고, 어떤 Instruction까지 수행했는지

### 프로세스의 주소 공간

- 프로세스의 주소 공간인 data에는 어떤 주소가 있는지, stack에는 어떤 함수의 결과값이 쌓여 있는지

### 프로세스 관련 커널 자료 구조

- 운영체제가 프로세스를 관리하기 위해 자신의 data영역에 두는 PCB
- kernel stack
    - 커널의 code는 다수의 프로세스가 사용할 수 있기 때문에 각 프로세스마다 stack를 별도로 두고 있다.
    - 따라서 프로세스의 현재 상태를 커널의 스택을 통해서도 알 수 있다.

## 프로세스의 상태

### 실행(Running)

- CPU를 잡고 Instruction 을 수행중인 상태

### 준비(Ready)

- 메모리 등 다른 조건을 모두 만족하고 CPU를 기다리는 상태

### 봉쇄(Blocked)

- CPU를 주어도 당장 사용할 수 없는 상태
- 프로세스 자신이 요청한 이벤트가 즉시 만족되지 않아 이를 기다리는 상태
    
    예) 디스크에서 파일을 읽어와야 하는 경우
    

### 중지(Suspended)

- 외부적인 이유로 프로세스의 수행이 정지된 상태
- 중기 프로세스에 의해 프로세스가 통째로 디스크로 swap out 된 경우
- 사용자가 프로그램을 일시 정지시킨 경우(Break key) ⇒ 사람이 프로세스를 다시 실행시켜주어야 다시 준비상태로 갈 수 있다.

### 봉쇄 VS 중지

- 자신이 요청한 이벤트(I/O 요청)가 만족될 경우 봉쇄
- 외부에서 프로세스를 중지시킨 경우 중지

![프로세스 상태도.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72c9ea68-b8ad-4cb1-a30f-3473c9bf3af0/프로세스_상태도.jpg)

![프로세스 상태.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b0accdc9-145c-4d38-8b50-d5534e00f322/프로세스_상태.jpg)

## PCB(프로세스 상태 블록)

- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보

### 구성요소

- OS가 관리상 사용하는 정보
- CPU 수행 관련 하드웨어 값
- 메모리 관련
- 파일 관련

## 컨텍스트 스위칭(문맥 교환) - 아주 중요

- CPU를 **한 프로세스에서 다른 프로세스로** 넘겨주는 과정
- 문맥 교환 시 필요한 작업
    - 커널 Data의 프로세스A의 PCB에 문맥을 저장
    - 저장했던 프로세스 B의 PCB를 하드웨어에 넘겨줌
- 사용자 프로세스로부터 CPU가 운영체제로 넘어가는 것은 컨텍스트 스위치가 아니다.

## 스케쥴러

### 장기 스케쥴러

- Job Scheduler라고도 한다.
- new 상태에 있는 프로세스 중 어떤 것들을 ready queue로 보낼지를 결정하는 것
- 멀티프로그래밍의 정도를 제어 ⇒ 메모리에 올라가있는 프로세스의 수를 제어
- 시분할 시스템에는 장기 스케쥴러가 없다. ⇒ 시분할 시스템은 어차피 프로그램이 시작될 때 메모리에 프로세스를 여러 개 올려놓기 때문

### 중기 스케쥴러

- Swapper라고도 한다.
- 메모리에서 프로세스를 디스크로 쫓아냄으로써 멀티프로그래밍의 정도를 제어한다.

### 단기 스케쥴러

- CPU 스케쥴러라고도 한다.
- 즉, CPU를 어떤 프로세스에 줄 지를 결정하는 것
- millisecond단위

### 쓰레드

- 프로세스 내부에 CPU 수행단위가 여러 개 있는 경우
- 프로세스의 주소를 한 개만 띄워놓고 program counter만 여러 개로 두어
- 프로세스 하나에서 메모리 주소 공간과 프로세스 상태, 프로세스가 사용하는 각종 자원들만 공유하고 CPU수행과 관련된 정보(레지스터, 프로그램 카운터, 스택)과 같은 것들은 쓰레드들 각각이 별도로 가진다.
- CPU를 수행하는 단위
- lightweight process 라고도 한다.

### 쓰레드의 구성

- 프로그램 카운터
- 레지스터 셋(register set)
- 스택(stack space)

### 쓰레드가 동료 쓰레드와 공유하는 부분(task)

- code section
- data section
- OS resources

### 쓰레드의 장점 4가지

1. 응답성
- 하나의 프로세스 안에 쓰레드를 여러 개 둘 경우, 쓰레드 하나가 블록 상태일 때 다른 쓰레드는 CPU 실행 상태인 게 가능하다. 이 경우 더욱 빠른 실행이 가능하다.
    
    예) 브라우저에서 네이버 화면을 띄운다고 할 때, 멀티 쓰레드로 프로그램이 실행될 경우 네이버 화면에서 그림이 뜨는 동안 텍스트가 먼저 뜨게 되어 사용자에게 빠른 응답이 가능하게 된다.
    
2. 자원 공유
- 동일한 일을 수행하는 작업을 쓰레드끼리 공유하게 될 경우 자원을 절약하고 성능 향상의 효과를 얻을 수 있다.
- 코드, 데이터, 각종 OS자원을 공유한다.
3. 경제성
- 프로세스를 여러 개 만드는 것에 비해 한 프로세스 내부에서 쓰레드를 여러 개 만드는 것이 훨씬 경제적이다.
- 컨텍스트 스위칭의 경우에도 프로세스 간의 컨텍스트 스위칭보다 쓰레드끼리의 스위칭이 훨씬 경제적이다.
4. 멀티프로세서 아키텍쳐(CPU가 여러개) 하에서 병렬성
- CPU가 여러 개 달린 컴퓨터의 경우, 병렬성을 높일 수 있다.
    
    예) 1000*1000 행과 열을 곱하게 될 경우 여러 쓰레드를 사용하여 계산된 결과를 합쳐서 그 결과를 더욱 빨리 도출할 수 있게 된다.
    

### 개괄적인 쓰레드 구현 방법

- 커널 쓰레드
    - 쓰레드가 여러 개 있다는 사실을 운영체제 커널이 알고 있다.
    - 쓰레드가 넘어가는 것도 커널이 CPU 스케쥴링을 하듯이 넘겨주게 된다.
- 유저 쓰레드
    - 라이브러리를 통해서 지원된다.
    - 프로세스 안에 쓰레드가 여러개 있다는 사실을 운영체제는 모른다.
    - 프로세스 본인이 내부에서 CPU 수행단위를 여러 개 두면서 쓰레드를 운영한다.
- real time 쓰레드
