# os_study 2주차 - 01

## 1. 프로세스

> “Process is a program in execution”
> 

✔️ 프로세스의 문맥(context)

- CPU 수행 상태를 나타내는 하드웨어 문맥
    - 하드웨어 문맥
        - Program Counter
        - 각종 register
- 프로세스의 주소 공간 (프로세스마다 각자의 주소공간을 가지고 있음)
    - code, data, stack
- 프로세스 관련 커널 자료 구조
    - PCB (Process Control Block)
    - Kernel stack

✔️ 프로세스는 상태가 변경되며 수행된다

- Running
    - CPU를 잡고 Instruction을 수행중인 상태
- Ready
    - CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)
- Blocked (wait, sleep)
    - CPU를 주어도 당장 Instruction을 수행할 수 있는 상태
    - Process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태

❗New : 프로세스가 생성중인 상태

❗Termonated: 수행(execution)이 끝난 상태

### 🌟 프로세스 상태도

![image](https://user-images.githubusercontent.com/67252475/158180436-40a50fc5-2c26-4935-a195-b00796adbc1a.png)


## 2. PCB

- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
- 다음의 구성 요소를 가진다(구조체로 유지)
    - OS가 관리상 사용하는 정보
        - process state, process ID
        - scheduling Information, priority
    - CPU 수행 관련 하드웨어 값
        - Program counter, registers
    - 메모리 관련
        - Code, data, stack의 위치 정보
    - 파일 관련
        - Open file descriptors
        

## 3. 문맥 교환 (Context Switch)

✔️ CPU를 한 프로세스에서 다른 프로세르로 넘겨주는 과정

✔️ CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행

- CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
- CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
    - 프로세스가 이전에  실행 중이던 상태부터 다시 실행하기 위해

```swift
문맥교환은 **Timer Interuppt**가 발생하거나 **I/O SystemCall**이 발생할 때 이뤄진다. 
사용자 프로그램이 **Interuppt**를 발생시키거나 **SystemCall**을 하여 사용자 모드에서 커널모드로 변경되는 것은
문맥교환이 아니다. 

사용자모드에서 커널모드로 변경되는 것도 문맥교환은 이러나지 않았지만 이전에 실행했던 
사용자 프로그램이 실행 중이던 정보를 PCB에 저장하기 때문에 약간의 문맥은 저장이 되지만
문맥교환처럼 프로세스 자체가 변경되는 것보다 오버헤드가 적다.

문맥교환이 발생하면 해당 프로세스가 사용하던 **Cache Memory**를 **Flush** 해야하기 때문에 커널모드와 사용자모드 
스위칭보다 상당한 오버헤드가 발생한다.
```

## 4. 프로세스를 스케줄링하기 위한 큐


# 정리 중...