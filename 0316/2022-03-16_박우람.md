# os_study 2주차 - 01

## 1. 프로세스

> “Process is a program in execution”
> 

✔️ 프로세스의 문맥(context)

- CPU 수행 상태를 나타내는 하드웨어 문맥
    - 하드웨어 문맥
        - Program Counter
        - 각종 register
- 프로세스의 주소 공간 (프로세스마다 각자의 주소공간을 가지고 있음)
    - code, data, stack
- 프로세스 관련 커널 자료 구조
    - PCB (Process Control Block)
    - Kernel stack

✔️ 프로세스는 상태가 변경되며 수행된다

- Running
    - CPU를 잡고 Instruction을 수행중인 상태
- Ready
    - CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)
- Blocked (wait, sleep)
    - CPU를 주어도 당장 Instruction을 수행할 수 없는 상태
    - Process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태
- Suspended (stopped)
    - 외부적인 이유로 프로세스의 수행이 정지된 상태
        - 사용자가 프로그램을 일시 정지시킨 경우 (break key)
        - 메모리에 너무 많은 프로세스가 올라와 있을 때
        - 시스템이 특정한 이유로 프로세스를 잠시 중단시킨 경우
    - 프로세스는 통째로 디스크에 swap out 된다.

❗New : 프로세스가 생성중인 상태

❗Terminated: 수행(execution)이 끝난 상태

❗Blocked: 자신이 요청한 event가 만족되면 Ready

❗Suspended: 외부에서 resume해 주어야 Active

### 🌟 프로세스 상태도

![image](https://user-images.githubusercontent.com/67252475/158180436-40a50fc5-2c26-4935-a195-b00796adbc1a.png)


## 2. PCB

- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
- 다음의 구성 요소를 가진다(구조체로 유지)
    - OS가 관리상 사용하는 정보
        - process state, process ID
        - scheduling Information, priority
    - CPU 수행 관련 하드웨어 값
        - Program counter, registers
    - 메모리 관련
        - Code, data, stack의 위치 정보
    - 파일 관련
        - Open file descriptors
        

## 3. 문맥 교환 (Context Switch)

✔️ CPU를 한 프로세스에서 다른 프로세르로 넘겨주는 과정

✔️ CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행

- CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
- CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
    - 프로세스가 이전에  실행 중이던 상태부터 다시 실행하기 위해

```swift
문맥교환은 **Timer Interuppt**가 발생하거나 **I/O SystemCall**이 발생할 때 이뤄진다. 
사용자 프로그램이 **Interuppt**를 발생시키거나 **SystemCall**을 하여 사용자 모드에서 커널모드로 변경되는 것은
문맥교환이 아니다. 

사용자모드에서 커널모드로 변경되는 것도 문맥교환은 이러나지 않았지만 이전에 실행했던 
사용자 프로그램이 실행 중이던 정보를 PCB에 저장하기 때문에 약간의 문맥은 저장이 되지만
문맥교환처럼 프로세스 자체가 변경되는 것보다 오버헤드가 적다.

문맥교환이 발생하면 해당 프로세스가 사용하던 **Cache Memory**를 **Flush** 해야하기 때문에 커널모드와 사용자모드 
스위칭보다 상당한 오버헤드가 발생한다.
```

<aside>
💡 프로세스의 문맥이란 프로세스 실행상태와 프로세스 자원 등 커널에서 관리하는 <b>프로세스 실행 정보</b>를 말한다.

</aside>

## 4. 프로세스를 스케줄링하기 위한 큐

✔️  Job queue

- 현재 시스템 내에 있는 모든 프로세스의 집합

✔️ Ready queue

- 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합

✔️ Device queue

- I/O device의 처리를 기다리는 프로세스의 집합

 

```
💡 이와 같은 큐는 소프트웨어 자원을 기다리는 경우에도 필요하다. 예를 들면 공유 데이터에 대한 접근 권한은 소프트웨어 자원으로 분류될 수 있다. 어떠한 프로세스가 공유 데이터를 사용하는 중에 다른 프로세스가 같은 데이터를 접근하면 일관성이 훼손될 수 있기 때문에 매 시점 하나의 프로세스만이 접근할 수 있도록 해야한다.
```

## 5. 스케줄러 (Scheduler)

✔️  Long-term scheduler (장기 스케줄러 or Job Scheduler)

- 시작 프로세스 중(new 상태의 프로세스) 어떤 것들을 ready queue로 보낼지 결정
- 프로세스에 메모리(및 각종 자원)을 주는 문제
- degree of Multiprogramming을 제어
- time sharing system에는 보통 장기 스케줄러가 없음 (무조건 ready 상태)
- 현대의 운영체제에는 장기 스케줄러가 없다

✔️ Short-term scheduler (단기 스케줄러 or CPU scheduler)

- 어떤 프로세스를 다음번에 running 시킬지 결정
- 프로세스에 CPU를 주는 문제
- 충분히 빨라야 함 (milliseconde 단위)

✔️ Medium-Tern Scheduler (중기 스케줄러 or Swapper)

- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
- 프로세스에게서 memory를 뺏는 문제
- degree of Multiprogramming을 제어

```swift
💡 스왑아웃 대상 0순위는 봉쇄상태의 프로세스다.

봉쇄상태의 프로세스를 스왑아웃 시켜도 메모리가 부족하면 타이머 인터럽트가 발생하여 준비큐로 이동하는 프로세스를 추가적으로 스왑아웃 시킨다.

준비큐에 너무 많은 프로세스가 존재하면 개별 프로세스에 배정되는 메모리양이 지나치게 적어지고 CPU를 한번 할당받은 후 다시 할당받기 까지 오랜 시간이 소요되기 때문이다.

```

## 6. Thread

> “A Theard ( or Lightweigth process) is a basic unit of CPU utilization”
> 

✔️ Thread의 구성 (CPU 수행과 관련)

- program counter
- register set
- stack space

✔️ Thread가 동료 Thread와 공유하는 부분 (=task)

- code section
- data section
- OS resource

✔️  전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다.

✔️  다중 쓰레드로 구성된 태스크 구조에서는 하나의 서버 쓰레드가 블럭된 상태인 동안에도 동일한 태스크 내의 다른 쓰레드가 실행되어 빠른 처리가 가능하다.

✔️  동일한 작업을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.

✔️  스레드를 사용하면 병렬성을 높일 수 있다.

- 멀티코어 컴퓨터에서 얻는 장점

✔️  멀티 프로세스보다 멀티 스레드가 가볍다.

- 멀티 프로세스의 경우 각각의 프로세스마다 자원을 별도로 생성하는 반면, 멀티 스레드는 CPU 수행과 관련된 부분만 생성하고 code, data, os 자원같은 경우 프로세스의 메모리 영역을 참조한다.

```
💡 멀티 쓰레드 웹 서버를 예로 들면, 한 요청이 끝날 때까지 기다렸다가 다음 요청을 처리하는 게 아닌 쓰레드마다 각각의 요청을 처리할 수 있다.
```

## 7. Thread 의 장점

✔️ Responsiveness

- multi-threaded
    - 만약 하나의 Thread 블럭되면 (eg network) 또 다른 Thread 작업을 이어간다. (eg display)

✔️ Resource Sharing

- 여러개의 Thread 코드영역, 데이터 영역 등 프로세스 자원(CPU 수행에 필요한 자원)을 공유할 수 있다.

✔️ Economy

- 프로세스 문맥교환과 프로세스 생성은 Thread 스위칭, Thread 생성보다 오버헤드가 상당히 크다
    - 솔라리스 운영체제의 경우 오버헤드가 각각 30배 5배

✔️ Utilization of MP Architecutres

- 각 쓰레드가 서로 다른 CPU에서 병렬적으로 수행될 수 있다. (멀티 프로세서 환경)

---
**[질문 리스트]**

**1. 프로세스 문맥교환이 어떠한 상황에서 발생하는지 설명해주세요.**

프로세스 문맥교환은 타이머 인터럽트가 발생하거나 I/O System call이 발생하면 

**2. 적은 양의 메모리를 많은 프로세스에게 할당할 때 발생하는 문제점과 이를 해결하기 위해 개발된 스케줄러를 하나만 선택하여 설명해주세요.**

적은 양의 메모리를 많은 프로세스에게 할당하면 Disk I/O 발생 확률이 높아지기 때문에 성능이 저하되는 문제가 발생할 수 있습니다.
이러한 문제를 해결하기위한 여러 스케줄링 기법이 있는데 그 중에서 현대에서 가장 유용하게 사용되고 있는 중기 스케줄러에 대해 설명하겠습니다.
중기 스케줄러는 타이머 인터럽트가 발생한 프로세스나 봉쇄상태의 프로세스를 메모리에서 쫓아내고 suspend 상태로 변경합니다. 
이때 우선순위는 봉쇄상태의 프로세스가 먼저 쫓겨나고, 봉쇄상태의 프로세스를 쫓아내도 메모리가 부족한 경우에 타이머 인터럽트가 발생한 프로세스를 추가적으로 쫓아냅니다.

**3. 프로세스 제어블록이란 무엇인지 설명하고 프로세스 제어블록의 요소들에 대해 아는대로 설명해주세요.**

프로세스 제어블록이란 PCB로도 불리고, 프로세스 스왑이 발생했을 때 프로세스의 문맥을 저장하는 역할을 담당합니다.
프로세스 제어블록은 PC(프로그램 카운터), Data의 Stack 위치정보, 프로세스 아이디, 프로세스 상태로 구성되어 있습니다.
프로그램 카운터는 해당 프로세스가 마지막으로 실행했던 영역을 저장하고 있고, Data, Stack의 위치정보는 프로그램 코드에 관련된 정보의 위치가 저장되어 있습니다.

**4. 4가지의 프로세스 상태에 대해 각각 설명해주세요.**

프로세스는 Running, Ready, Block, Terminated, Suspended 상태가 있습니다.
이중에서 Ready, Block, Terminated, Suspended 상태에 대해 설명하자면, 
Ready 상태는 프로세스가 CPU를 할당받았을 때 당장 실행할 준비가 되어있는 상태입니다.
Block 상태는 프로세스가 요청한 Event가 수행될 때까지 대기 중인 상태를 의미합니다.
Terminated 상태는 프로세스 실행이 종료되었지만 아직 메모리에 저장되어있는 데이터가 회수가 되어있지 않은 상태입니다.
Suspended 상태는 프로세스가 외부요인에 의해 종료된 상태를 의미 합니다.


**5.프로세스와 스레드 각각의 개념을 설명하고, 멀티프로세스보다 멀티스레드가 효율적인 이유를 말씀해주세요.**

실행중인 프로그램을 의미하고 스레드는 한 프로세스의 경량 프로세스라고 소개할 수 있습니다. 
멀티 프로세스의 경우 프로세스마다 같은 정보를 가지고 있다고 해도 새로운 메모리 영역을 할당받는 반면에
멀티 스레드는 프로그램 실행에 필요한 최소한의 정보만을 새롭게 할당받고 나머지 정보는 프로세스의 메모리를 공유하여 사용할 수 있기 때문에
메모리를 효율적으로 관리하는 측면에서 멀티 프로세스보다 멀티 스레드가 유용합니다.

**6. 스레드의 장점을 아는 대로 전부 말씀해주세요.**

멀티 스레드 웹 프로그래밍 환경을 예로 들면, 웹 홈페이지에 접속할 때 데이터를 가져오는 스레드, 화면을 표시하는 작업을 진행하는 스레드가 여럿 있으면
하나의 작업을 수행될 때까지 기다리지 않고 다른 스레드에서 나머지 작업을 진행할 수 있기 때문에 응답속도가 증가한다는 장점이 있습니다.
