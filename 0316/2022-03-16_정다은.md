# 운영체제 스터디 OS오예스 (2022-03-16 WED 📚)
## 5장 프로세스 관리 Process

### 📂 프로세스의 개념
**프로세스**: program in execution 실행 중인 프로그램

**프로세스의 문맥 (context)**: 특정 시점의 프로세스의 상태를 규명

- CPU 수행 상태를 나타내는 **하드웨어 문맥**
  - Program Counter
  - 각종 레지스터
- **프로세스의 주소 공간**
  - code, data, stack
- 프로세스 관련 **커널 자료 구조**
  - PCB
  - kernel stack
<br/>

### 📂 프로세스의 상태
<p align="center"><img src="https://images.velog.io/images/dianestar/post/29559259-bd2e-4474-9807-8bcb71f20086/image.png" width="50%" position="center"/></p>

- **Running 실행**: CPU를 점유하고 instructions를 수행 중인 상태
- **Ready 준비**: 다른 모든 준비는 끝났음을 전제로 CPU 할당만을 기다리는 상태
- **Blocked (Wait, Sleep) 봉쇄**: CPU를 할당 받아도 당장 instructions 수행이 불가능한 상태 *ex) I/O 작업 진행 중*
- New 시작: 프로세스가 생성 중인 상태
- Terminated 완료: 프로세스가 종료 중인 상태
<br/>

### 📂 프로세스 제어 블록
**PCB; Process Control Block**: 커널이 각 프로세스마다 관리하기 위해 커널 내에 갖고 있는 자료 구조

- 운영체제가 관리상 사용하는 정보
  - Process State, Process ID
  - scheduling information, priority
- CPU 수행 관련 하드웨어 값
  - Program Counter, Registers
- 메모리 관련
  - code, data, stack의 위치 정보
- 파일 관련
  - open file descriptors
<br/>

### 📂 문맥교환
**Context Switching**<br/>
: 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제여권이 이양되는 과정<br/>
: 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정<br/>
*ex) 타이머 인터럽트가 발생하는 경우, I/O 요청 등으로 봉쇄 상태로 바뀌는 경우 등*

- CPU를 빼앗길 때
👉 프로세스의 문맥을 커널에 존재하는 PCB에 저장
- CPU를 다시 얻었을 때
👉 재개를 위해 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원

>  🚨 **시스템콜, 인터럽트(타이머 인터럽트 외) 발생 시에는 문맥교환이라고 하지 않는다 !**
>  
> 이는 하나의 **프로세스의 실행모드가 user mode에서 kernel mode로 전환되는 것**일 뿐, 문맥교환이 아니다.<br/>
해당 경우에도 CPU의 제어권이 운영체제로 넘어오게 되면서 문맥의 일부를 PCB에 저장해야 하지만,<br/>
**cache memory flush가 일어나는 문맥교환에 비해 오버헤드가 훨씬 적다.** 
> - 사용자 프로세스 A -> 사용자 프로세스 B : <span style="blue">문맥교환 O</span>
> - 사용자 프로세스 A -> 운영체제 -> 사용자 프로세스 A : 문맥교환 X user mode로 복귀 O 
> - 사용자 프로세스 A -> 운영체제 -> 프로세스 B : 문맥교환 O
> <p align="center"><img src="https://images.velog.io/images/dianestar/post/d5b7705a-56c9-4e13-a71b-93826af54a14/image.png" width="75%" /></p>
<br/>

### 📂 프로세스를 스케줄링하기 위한 큐
- Job Queue: 현재 시스템 내에 있는 모든 프로세스를 관리하는 큐로, Ready Queue 프로세스 + Device Queue 프로세스 포함
- Ready Queue: 준비 상태에 있는 프로세스들을 줄 세우는 큐
- Device Queue: 특정 자원을 기다리는 프로세스들을 줄 세우는 큐
<br/>

### 📂 스케줄러
**Scheduler**: 어떤 프로세스에게 자원을 할당할지 순서를 정해주는 운영체제 커널의 코드
- **Long-term scheduler (Job Scheduler)**<br/>
: 시작 프로세스 중 어떤 프로세스를 Ready Queue 로 보낼지 결정<br/>
: new 상태 -> ready 상태, 즉 메모리에 올라가는 것을 admitted하는 문제에 관여<br/>
: Degree of Multiprogramming (메모리에 동시에 올라가있는 프로세스의 수)를 제어<br/>
: 시분할 시스템에는 보통 장기 스케줄러가 없음
- **Short-term scheduler (CPU Scheduler)**<br/>
: Ready Queue에 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할 것인지 결정
- **Medium-term scheduler (Swapper)**<br/>
: 여유 공간 마련을 통한 성능 향상을 위해 프로세스에게서 메모리를 빼앗는 문제에 관여 (swap-out)<br/>
: 메모리에 적재된 프로세스의 수를 동적으로 조절<br/>
: Degree of Multiprogramming을 제어<br/>
: 현대의 시분할 시스템에서 많이 활용

> 📌 **suspended(stopped)**<br/>
: 중기 스케줄러의 등장으로 인해 추가된 프로세스의 상태<br/>
: 외부적인 이유(중기 스케줄러의 swap-out 또는 사용자가 break key 등으로 프로그램을 일시정지 시킨 경우)로 프로세스의 수행이 정지된 상태<br/>
: 외부에서 재개시키지 않는 이상 다시 활성화될 수 없음<br/>
> <br/>
> cf) **blocked vs suspended**
> - blocked: CPU 관련 연산은 아니지만 여전히 일하고 있는 상태로, 자신이 요청한 event(ex. I/O작업)가 만족되면 ready 상태로 전환
> - suspended: 메모리를 조금도 보유하지 않고 디스크에 통째로 swap-out 된 상태로, 외부에서 resume해 주어야 active됨
> <br/>
> <p align="center"><img src="https://images.velog.io/images/dianestar/post/fecad99c-af9d-44ea-af51-e39d90f3bfa5/image.png" width="50%" /></p>
<br/>

### 📂 스레드
**Thread**<br/>
: lightweight process, a basic unit of CPU utilization<br/>
: 프로세스 내부에서 CPU가 수행되는 흐름의 단위

- 스레드가 독자적으로 가지는 부분
  - **Program Counter**
  - **Register Set**
  - **Stack Space**

- 스레드가 동료 스레드와 공유하는 부분
  - **code section**
  - **data section**
  - **OS resources**

- 스레드의 장점
  - **Responsiveness 빠른 응답성**<br/>
  👉 다중 스레드로 구성된 프로세스에서는 하나의 스레드가 blocked 상태일 때에도 동일한 프로세스 내 다른 스레드가 CPU를 할당 받고 running 되어 빠른 처리가 가능
  - **Resource Sharing 자원 공유**<br/>
  👉 프로세스를 여러 개만들 경우 프로세스마다 별도의 주소공간이 만들어져 메모리 낭비로 이어지는 반면 스레드는 공유할 수 있는 자원들을 최대한 공유 가능<br/>
  - **Economy 경제성**<br/>
  👉 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있음<br/>
  👉 프로세스 하나를 만들거나 프로세스 간 문맥교환을 하는 것은 오버헤드가 큰 반면 스레드는 대부분의 문맥을 그대로 쓸 수 있음
  - **Utilization of MP Architecture**<br/>
  👉 CPU가 여러 개 있는 환경에서 각각의 스레드가 서로 다른 프로세스에서 병렬적으로 실행되며 효율성을 높일 수 있음

- 스레드의 종류
  - Kernel Threads (supported by kernel): 스레드가 여러 개 존재함을 커널이 알고 있음. 스레드 간의 전환도 커널이 담당.
  - User Threads (supported by library): 스레드가 여러 개 존재함을 커널이 모름. 유저 프로그램이 직접 관리.
  - Real-Time threads
***
### ❓ 문제
**Q1. 프로세스 문맥교환이 어떠한 상황에서 발생하는지 설명해주세요.**

**Q2. 적은 양의 메모리를 많은 프로세스에게 할당할 때 발생하는 문제점과 이를 해결하기 위해 개발된 스케줄러를 하나만 선택하여 설명해주세요.**

**Q3. 프로세스 제어블록이란 무엇인지 설명하고 프로세스 제어블록의 요소들에 대해 아는대로 설명해주세요.**

**Q4. 4가지의 프로세스 상태에 대해 각각 설명해주세요.**

**Q5.프로세스와 스레드 각각의 개념을 설명하고, 멀티프로세스보다 멀티스레드가 효율적인 이유를 말씀해주세요.**
 
**Q6. 스레드의 장점을 아는 대로 전부 말씀해주세요.**
